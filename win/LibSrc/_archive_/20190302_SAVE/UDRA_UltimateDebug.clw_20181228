					MEMBER()

!MG Changes:
! Removed _ABC[Dll|Link]Mode_ equates
! Added ODS - an CW String to CSTRING wrapper (plus <13,10>)
! DbgClearView - uses ODS - as it shouldn't appear in the AsciiFile
! Using UltimateString, for CR Splitting
! SELF.EventQ.FieldName = SELF.GetFEQDescr(FIELD())
! ShowProcedureInfo - changed code inside of the ACCEPT loop to do a CASE ACCEPTED()
! Split out functionality into UltimateDebugerCore
! Discovered that .UserEventNameQ was left null in .Construct, nor was it Free'd()/Disposed in Destruct
! Discovered .Destruct was doing a FREE without first checking if not NULL
!RA Changes:
! Added Methods to do global tracking of how deep in the rabit hole you are
! Added Attribute to keep track of the nested level

!--------------------------
!ClarionLive Skeleton Class
!--------------------------
!==============================================================================
!If all fields begin with the same prefix, then you can have that auto-stripped
!by uncommenting the following line.
!E_StripPrefix         EQUATE(1)
!==============================================================================
WidthMultiplier:Narrow          EQUATE(5)  !normal columns (numbers, lowercase, etc.)
WidthMultiplier:Wide            EQUATE(7)  !uppercase columns
!==============================================================================
  INCLUDE('EQUATES.CLW')
  INCLUDE('Errors.clw')
  INCLUDE('UDRA_UltimateDebug.INC'),ONCE
  INCLUDE('UDRA_UltimateString.inc'), ONCE
! ToDo _wsldebug$setlogfile

   MAP
      MODULE('kernel')
         debugbreak(),PASCAL !,RAW,NAME('debugbreak')
         OutputDebugString(*CSTRING),PASCAL,RAW,NAME('OutputDebugStringA')
      END
      MODULE('C%V%RUN%X%')
         RTL:NameMessage (*CSTRING Answer, UNSIGNED EventNum ),RAW,NAME('WslDebug$NameMessage')   !Note: use   Event() + EVENT:FIRST  else will get WM_*
         RTL:FieldName(SIGNED FEQ),*CSTRING,RAW,NAME('Cla$FIELDNAME')
      END
      ODS_MG (STRING xMSG)              ! RA.2018.03.03 - ???
	  ODS_RYB(STRING sMSG)              ! RA.2018.11.27: Added
   END


                                                           COMPILE('_ifdef_',EVENT:APP=0)
EVENT:APP                             EQUATE(08000h)
EVENT:APP_LAST                        EQUATE(0BFFFh)
                                                      !END_COMPILE('_ifdef_',EVENT:APP=0)
!==============================================================================

!Region Local Procedures
!==============================================================================
ODS_MG                                    PROCEDURE(STRING xMSG)
!==============================================================================
szMSG  &CSTRING
  CODE
  szMSG &= NEW CSTRING( SIZE(xMSG) + 3 )   ! 3 = LEN(<13,10,0>)
  szMSG  =                   xMSG & '<13,10,0>'
  OutputDebugString(szMSG)
  DISPOSE(szMSG)
  RETURN
!==============================================================================
ODS_RYB                                  PROCEDURE(STRING sMSG)
!==============================================================================
szMSG  &CSTRING
  CODE
  szMSG &= NEW CSTRING( SIZE(sMSG) + 3 )   ! 3 = LEN(<13,10,0>)
  szMSG  =                   sMSG & '<13,10,0>'
  OutputDebugString(szMSG)
  DISPOSE(szMSG)
  RETURN
!EndRegion Local Procedures

!Region UltimateDebugCore
!==============================================================================
UltimateDebugCore.Construct                PROCEDURE
!==============================================================================
  CODE
  SELF.lThread          = THREAD()                  ! RA.2018.11.23 - Thread Id
  SELF.gLevels          = 0                         ! RA.2018.11.27 - Nesting Level
  SELF.szEXE            = '<0>'                     ! RA.2018.11.27 - Executable
  SELF.szMOD            = '<0>'                     ! RA.2018.11.27 - Module 
  SELF.szPRC            = '<0>'                     ! RA.2018.11.27 - Procedure
   
  SELF.UserEventNameQ &= NEW qtUserEventNameMG
  SELF.SetEventOffset()

  SELF.ShowAll          = TRUE
  SELF.ShowField        = FALSE
  SELF.ShowFocus        = FALSE
  SELF.ShowSelected     = FALSE
  SELF.ShowSelStart     = FALSE
  SELF.ShowSelEnd       = FALSE
  SELF.ShowKeyCode      = FALSE
  SELF.ShowError        = FALSE
  SELF.ShowThread       = FALSE
  SELF.ShowContents     = FALSE
  SELF.ShowScreenText   = FALSE
  SELF.ShowAcceptAll    = FALSE

  SELF.DebugPrefix      = '!'
  SELF.ASCIIFileName    = 'DebugLog.txt'

  SELF.DebugMe          = FALSE
  SELF.DebugOff         = FALSE
  SELF.DebugNoCR        = FALSE
  SELF.SaveToFile       = FALSE
  IF (SELF.DebugMe)
    SELF.Debug(':DEBUGME UltimateDebugCore.Construct')
    SELF.Debug(':DEBUGME:FLAG UltimateDebugCore.Construct SELF.DebugMe=(' & SELF.DebugMe & ')')
    SELF.Debug(':DEBUGME:FLAG UltimateDebugCore.Construct SELF.DebugOff=(' & SELF.DebugOff & ')')
    SELF.Debug(':DEBUGME:FLAG UltimateDebugCore.Construct SELF.DebugNoCR=(' & SELF.DebugNoCR & ')')
    SELF.Debug(':DEBUGME:FLAG UltimateDebugCore.Construct SELF.SaveToFile=(' & SELF.SaveToFile & ')')	
    SELF.Debug(':DEBUGME:LOG UltimateDebugCore.Construct LONGPATH=(' & LONGPATH() & ')')
    SELF.Debug(':DEBUGME:LOG UltimateDebugCore.Construct SELF.ASCIIFileName=(' & CLIP(SELF.ASCIIFileName) & ')')
  END 
  RETURN
!==============================================================================
UltimateDebugCore.Destruct                 PROCEDURE
!==============================================================================
  CODE
  IF ~(SELF.UserEventNameQ &= NULL)
    FREE(SELF.UserEventNameQ)
    DISPOSE(SELF.UserEventNameQ)
  END
 
  ! If we find a name here, we have put a name with an Enter method but we have not used and Exits method.
  ! So we just take care of it when we destruct. So if the Exits never gets done, it cleans itself up.  
  ! For the hand coders this saves time. You will have always have one Enter in. You might have several
  ! Exits out, and the class Destruct will catch them all. But the local debug class must always exist.
  ! For the ABC template generation you will have one call to the Enter method and one call the Exits method
  ! generated. This is probably best to be done around the first Run method that calls the program.
  ! That eliminates all the different paths that the ABC class object might exit and the need to catch them.
  ! So you can use a debug global a debug local or both types of debug objects. Just have different names.
  IF (SELF.szEXE <> '') THEN
    SELF.Debug(':EXITS (' & SELF.szEXE & '=' & SELF.szMOD & '=' & SELF.szPRC & ')')
    SELF.gLevels       -= 1
    SELF.szEXE          = '<0>'
    SELF.szMOD          = '<0>'
    SELF.szPRC          = '<0>'
  END

  IF (SELF.DebugMe)
    SELF.Debug(':DEBUGME UltimateDebugCore.Destruct')
  END
  RETURN
!==============================================================================
UltimateDebugCore.RawODS                   PROCEDURE(STRING xMsg)
!==============================================================================
szMSG   &CSTRING
  CODE
  szMSG &= NEW CSTRING( SIZE(xMSG) + 3 )   ! 3 = LEN(<13,10,0>)
  szMSG  =                   xMSG  & '<13,10,0>'
  OutputDebugString(szMSG)
  DISPOSE(szMSG)
  RETURN

!==============================================================================
UltimateDebugCore.LOW_RYB                  PROCEDURE(STRING pDebugString)
!==============================================================================
  CODE
  ODS_RYB(CLIP(pDebugString))
  RETURN
!==============================================================================
UltimateDebugCore.LOW_THREAD               PROCEDURE(STRING pMSG)
!==============================================================================
  CODE
  RETURN '[T' & SELF.lThread & ']' & pMSG
!==============================================================================
UltimateDebugCore.LOW_LEVEL                PROCEDURE(STRING pMSG)
!==============================================================================
  CODE
  RETURN SELF.LOW_THREAD('[L' & FORMAT(SELF.gLevels,@N03) & ']' & pMSG)
!==============================================================================
UltimateDebugCore.LOW_DEBUG                PROCEDURE(STRING pMSG)
!==============================================================================
  CODE
  IF pMSG[1] = ':' OR pMSG[1] = ' '
    RETURN SELF.LOW_LEVEL(      pMSG)
  ELSE 
    RETURN SELF.LOW_LEVEL(' ' & pMSG)
  END
!==============================================================================
UltimateDebugCore.LOW_PREFIX               PROCEDURE(STRING pMSG)
!==============================================================================
  CODE
  RETURN SELF.DebugPrefix & SELF.LOW_DEBUG(pMSG)

!==============================================================================
UltimateDebugCore.Debug                    PROCEDURE(STRING pMSG)
!==============================================================================
  CODE
  IF NOT SELF.DebugOff
    SELF.DebugToODS(pMSG)
  END
  IF     SELF.SaveToFile
    SELF.DebugToFile(pMSG)
  END
  RETURN	 
!==============================================================================
UltimateDebugCore.Enter                    PROCEDURE(STRING psEXE, STRING psMOD, STRING psPRC)
!==============================================================================
  CODE
  ! When you enter you save these for when you might have to use them when the destructor fires
  SELF.szEXE           = CLIP(psEXE) & '<0>' 
  SELF.szMOD           = CLIP(psMod) & '<0>'
  SELF.szPRC           = CLIP(psPRC) & '<0>'
  SELF.gLevels        += 1
  SELF.Debug(':ENTER (' & CLIP(psEXE) & '=' & CLIP(psMOD) & '=' & CLIP(psPRC) & ')')
  RETURN
!==============================================================================
UltimateDebugCore.Enter                    PROCEDURE(STRING psMSG)
!==============================================================================
  CODE
  SELF.gLevels        += 1
  SELF.Debug(':ENTER ' & CLIP(psMSG) & '')
  RETURN
!==============================================================================
UltimateDebugCore.Level                    PROCEDURE(STRING psMSG)
!==============================================================================
  CODE
  SELF.Debug(' ' & CLIP(psMSG) & '')
  RETURN
!==============================================================================
UltimateDebugCore.Exits                    PROCEDURE(STRING psMSG)
!==============================================================================
  CODE
  SELF.Debug(':EXITS ' & CLIP(psMSG) & '')
  SELF.gLevels        -= 1
  RETURN
!==============================================================================
UltimateDebugCore.Exits                    PROCEDURE(STRING psEXE, STRING psMOD, STRING psPRC)
!==============================================================================
  CODE
  ! When you exits here you clear these so they will not get used by the destructor
  SELF.Debug(':EXITS (' & CLIP(psEXE) & '=' & CLIP(psMOD) & '=' & CLIP(psPRC) & ')')
  SELF.gLevels        -= 1
  SELF.szEXE           = '<0>'
  SELF.szMOD           = '<0>'
  SELF.szPRC           = '<0>'
  RETURN

!==============================================================================
UltimateDebugCore.TableTraceEnable         PROCEDURE(*FILE pTable)
!==============================================================================
  CODE
  !IF (SELF.DebugMe) THEN  
    SELF.Debug(':DEBUGME UltimateDebugCore.TableTraceEnable(<39>' & NAME(pTable) & '<39>)')
  !END
  IF   EXISTS(CLIP(LONGPATH()) & '\trace.txt') = TRUE
  ELSE RETURN
  END 
 
  IF   SYSTEM{PROP:DriverTracing} = '1'
  ELSE SYSTEM{PROP:DriverTracing} = '1'
  END 

  SELF.TablesBeingTraced         += 1
 
  pTable{PROP:TraceFile}          = 'DEBUG:'
  pTable{PROP:Details}            = 1 
  pTable{PROP:Profile}            = 'DEBUG:' 
  pTable{PROP:LogSQL}             = 1 
  RETURN 
!==============================================================================
UltimateDebugCore.TableTraceDisable        PROCEDURE(*FILE pTable)
!==============================================================================
  CODE 
  !IF (SELF.DebugMe) THEN  
    SELF.Debug(':DEBUGME UltimateDebugCore.TableTraceDisable(<39>' & NAME(pTable) & '<39>)')
  !END
  SELF.TablesBeingTraced         -= 1
 
  IF SELF.TablesBeingTraced = 0 
    SYSTEM{PROP:DriverTracing}    = ''
  END 
 
  pTable{PROP:TraceFile}          = ''
  pTable{PROP:Details}            = 0 
  pTable{PROP:Profile}            = '' 
  pTable{PROP:LogSQL}             = 0
  RETURN 

!==============================================================================
UltimateDebugCore.DebugEntry               PROCEDURE(STRING pMSG)
!==============================================================================
   CODE
   SELF.Enter('===ENTRY=== ' & CLIP(pMSG))
   !SELF.Enter(CLIP(pMSG))
   RETURN
!==============================================================================
UltimateDebugCore.DebugLevel               PROCEDURE(STRING pMSG)
!==============================================================================
   CODE
   SELF.Level(CLIP(pMSG))
   RETURN
!==============================================================================
UltimateDebugCore.DebugExit                PROCEDURE(STRING pMSG)
!==============================================================================
  CODE
  !SELF.Exits(CLIP(pMSG))
  SELF.Exits('===EXIT=== ' & CLIP(pMSG))
  RETURN

!==============================================================================
UltimateDebugCore.DebugToODS               PROCEDURE(STRING pDebugString)
!==============================================================================
  CODE
  !IF (SELF.DebugMe) THEN  
  !  SELF.RawODS(SELF.LOW_PREFIX(':DEBUGME UltimateDebugCore.DebugToODS(.)'))
  !END
  !IF (SELF.DebugMe) THEN  
  !  SELF.RawODS(SELF.LOW_PREFIX(':DEBUGME:RAWODS UltimateDebugCore.Debug(<39>' & CLIP(pDebugString) & '<39>)'))
  !END
  IF SELF.DebugNoCR THEN
    SELF.RawODS(SELF.LOW_PREFIX(pDebugString))
	RETURN
  END
  IF INSTRING('<13><10>',pDebugString,1,1)>0 THEN
    IF (SELF.DebugMe) THEN  
      SELF.RawODS(SELF.LOW_PREFIX(':DEBUGME UltimateDebugCore.DebugToODS.Find(<39><<13><<10><39>)'))
    END
    DO Debug:SplitByCR
	RETURN
  END
  IF INSTRING('<13>',pDebugString,1,1)>0 THEN
    IF (SELF.DebugMe) THEN  
      SELF.RawODS(SELF.LOW_PREFIX(':DEBUGME UltimateDebugCore.DebugToODS.Find(<39><<13><39>)'))
    END
    DO Debug:SplitByCR
	RETURN
  END
  IF INSTRING('|',pDebugString,1,1)>0 THEN
    IF (SELF.DebugMe) THEN  
      SELF.RawODS(SELF.LOW_PREFIX(':DEBUGME UltimateDebugCore.DebugToODS.Find(<39>|<39>)'))
    END
    DO Debug:SplitByCR
	RETURN
  END
  SELF.RawODS(SELF.LOW_PREFIX(pDebugString))
  RETURN

Debug:SplitByCR ROUTINE
DATA
UString      UltimateString
LineNum      LONG,AUTO
  CODE
  UString.Assign(pDebugString)
  UString.Replace('|','<13>')
  UString.Replace('<10>','')
  UString.Split('<13>')
  LOOP LineNum = 1 TO UString.Records()
    SELF.RawODS(SELF.LOW_PREFIX(' ' & UString.GetLine(LineNum)))
  END
!==============================================================================
UltimateDebugCore.DebugToFile_StartEachRow         PROCEDURE()
!==============================================================================
  CODE
  RETURN '[' & FORMAT(TODAY(),@D010) & '-' & FORMAT(CLOCK(),@T07) & '] '
!==============================================================================
UltimateDebugCore.DebugToFile              PROCEDURE(STRING pDebugString)
!==============================================================================
ASC1:ASCIIFile   FILE,PRE(ASC1),DRIVER('ASCII'),CREATE
RECORD               RECORD,PRE()
STRING                  STRING(512)
							END
					  END
  CODE
  DO DebugToFile:Open !<-- inefficient

  IF SELF.DebugNoCR OR ((INSTRING('<13>',pDebugString,1,1)=0) AND (INSTRING('|',pDebugString,1,1)=0)) THEN
    ASC1:String = SELF.DebugToFile_StartEachRow() & SELF.LOW_DEBUG(pDebugString)
    ADD(ASC1:ASCIIFile)
  ELSE
     DO Debug:SplitByCR
  END

  CLOSE(ASC1:ASCIIFile) !<-- inefficient

Debug:SplitByCR ROUTINE
DATA
UString      UltimateString
LineNum      LONG,AUTO
  CODE
  UString.Assign(pDebugString)
  UString.Replace('|','<13>')
  UString.Replace('<10>','')
  UString.Split('<13>')
  LOOP LineNum = 1 TO UString.Records()
    ASC1:String = SELF.DebugToFile_StartEachRow() & SELF.LOW_DEBUG(UString.GetLine(LineNum))
    ADD(ASC1:ASCIIFile)
  END

DebugToFile:Open ROUTINE
    ASC1:ASCIIFile{PROP:Name} = SELF.ASCIIFileName
    IF SELF.SaveToFile
      IF ~EXISTS(ASC1:ASCIIFile{PROP:Name})
        CREATE(ASC1:ASCIIFile)
      END
      OPEN(ASC1:ASCIIFile)
    END
!==============================================================================
UltimateDebugCore.ClearDebugView           PROCEDURE()   !Requires Debugview 4.3 or greater
!==============================================================================
!From:  http://www.sysinternals.com/ntw2k/freeware/debugview.shtml
!       Clear-output string: When DebugView sees the special debug output string "DBGVIEWCLEAR" it clears the output.

!Note: If this doesn't appear to work, then you are either:
!          a) using an older version of debugview
!       OR b) you are filtering the message
  CODE
  SELF.LOW_RYB('DBGVIEWCLEAR') !Written this way to get the prefix, so the message won't be filtered

!==============================================================================
UltimateDebugCore.GPF                      PROCEDURE()
	CODE
	DebugBreak()

!==============================================================================
!==============================================================================
UltimateDebugCore.SetEventOffSet           PROCEDURE
  CODE
                                    COMPILE('**++** _C60_Plus_',_C60_)
  SELF.EventOffset = 0A000h
                                 !  **++** _C60_Plus_
                                    OMIT   ('**--** _PRE_C6_',_C60_)
  SELF.EventOffset = 01400h
                                 !  **--** _PRE_C6_

  IF UPPER(SELF.GetEventDescr(EVENT:ACCEPTED)) <> 'EVENT:ACCEPTED'
     DO SetEventOffSet:HuntForOffSet
  END
!==============================================================================
SetEventOffSet:HuntForOffSet            ROUTINE
  DATA
  !This method will rarely be called.
  !After some major version of CW, we may discover a new offset
EventNum                                LONG
Pass                                    BYTE
Lo                                      LONG
Hi                                      LONG
  code

  SELF.Debug('SELF.EventOffset is not correct, trying to find a correct value')

  SELF.EventOffset = CHOOSE(SELF.EventOffset = 01400h, 0A000h, 01400h)
  if UPPER(SELF.GetEventDescr(EVENT:ACCEPTED)) = 'EVENT:ACCEPTED' THEN RETURN END

  SELF.EventOffset = GETINI('Debuger','EventOffset', -1)
  CASE SELF.EventOffset
    OF -2 ; SELF.Debug('Stored value for EventOffset indicates no valid offset to be found, not searching')
    OF -1 ; SELF.Debug('SELF.EventOffset is not correct, searching for correct value')
  ELSE    ; IF UPPER(SELF.GetEventDescr(EVENT:ACCEPTED)) = 'EVENT:ACCEPTED'
               SELF.Debug('Using stored value for SELF.EventOffset')
               RETURN
            END
  END

  !The loops are split out to search more likely ranges first
  !for efficiency it makes more sense to check offsets incrementing by 100, searching for a result that starts with 'EVENT'
  LOOP Pass = 1 TO 4
    EXECUTE Pass
      BEGIN; Lo = 0A000h; Hi = 0AFFFh END
      BEGIN; Lo = 01000h; Hi = 01FFFh END
      BEGIN; Lo = 00000h; Hi = 00FFFh END
      BEGIN; Lo = 0B000h; Hi = 0FFFFh END
    END
    LOOP EventNum = Lo TO Hi
      SELF.EventOffset = EventNum
      IF UPPER(SELF.GetEventDescr(EVENT:ACCEPTED)) = 'EVENT:ACCEPTED'
        PUTINI('Debuger','EventOffset',SELF.EventOffset)
        RETURN
      END
    END
  END

  SELF.Debug('Could not find a working offset for .EventOffset')
  SELF.EventOffset = -2
  PUTINI('Debuger','EventOffset',SELF.EventOffset)
  RETURN
!==============================================================================
!==============================================================================
UltimateDebugCore.AddUserEvent             PROCEDURE(STRING argEventName,LONG argEventEquate)
  CODE
  IF ~SELF.UserEventNameQ &= NULL
     IF SELF.GetUserEvent(argEventEquate)
       SELF.UserEventNameQ.EventName    = argEventName
       PUT(SELF.UserEventNameQ)
     ELSE
       SELF.UserEventNameQ.EventEquate  = argEventEquate
       SELF.UserEventNameQ.EventName    = argEventName
       ADD(SELF.UserEventNameQ)
     END
  END
!==============================================================================
UltimateDebugCore.GetUserEvent             PROCEDURE(LONG argEventEquate)!string
  CODE
  !IF (SELF.DebugMe) THEN
  !  SELF.RawODS('DEBUGME: UltimateDebugCore.GetUserEvent')
  !END

  IF ~SELF.UserEventNameQ &= NULL
     SELF.UserEventNameQ.EventEquate  = argEventEquate
     GET(SELF.UserEventNameQ, SELF.UserEventNameQ.EventEquate)
     RETURN CHOOSE( ERRORCODE()=0, SELF.UserEventNameQ.EventName, '')
  ELSE
     RETURN ''
  END
!==============================================================================
UltimateDebugCore.GetEventDescr_WM         PROCEDURE(LONG xEvent)!,string  !prototype set to default to -1
lcl:Retval                              LIKE(qtUserEventNameMG.EventName)
  CODE
  RTL:NameMessage(lcl:RetVal, xEvent) !<-- sets lcl:RetVal
  RETURN lcl:Retval
!==============================================================================
UltimateDebugCore.GetEventDescr            PROCEDURE()
  CODE
  RETURN SELF.GetEventDescr(EVENT())
!==============================================================================
UltimateDebugCore.GetEventDescr            PROCEDURE(LONG xEvent)!,string  !prototype set to default to -1
lcl:Retval                              LIKE(qtUserEventNameMG.EventName)
!lcl:EventNum                            UNSIGNED
lcl:Position                            LONG

  CODE
    lcl:RetVal = SELF.GetUserEvent( xEvent )
    IF ~lcl:RetVal
      CASE xEvent
        OF Event:User                      ; lcl:RetVal = 'EVENT:User'
        OF Event:User + 1 TO Event:Last    ; lcl:RetVal = 'EVENT:User + '& xEvent - Event:User
        OF Event:APP                       ; lcl:RetVal = 'EVENT:App'
        OF Event:APP  + 1 TO Event:APP_LAST; lcl:RetVal = 'EVENT:App + ' & xEvent - Event:APP
      ELSE
        IF SELF.EventOffset = -2   !indicates could not find a valid offset
          lcl:RetVal = 'EVENT['& xEvent &']'
        ELSE
          RTL:NameMessage(lcl:RetVal, xEvent + SELF.EventOffset) !<-- sets lcl:RetVal
        END
      END
    END

    RETURN lcl:RetVal   ![7:LEN(CLIP(lcl:RetVal))]
!==============================================================================
UltimateDebugCore.GetFEQDescr              PROCEDURE(SIGNED argFEQ)!,string  !prototype set to default to -1
lcl:Retval    CSTRING(40) !<--- some arbitrary length
  CODE
  argFEQ     = CHOOSE(argFEQ = -1, FIELD(), argFEQ)
  lcl:RetVal = RTL:FieldName(argFEQ)

  RETURN lcl:RetVal !CLIP(lcl:RetVal)
!==============================================================================
UltimateDebugCore.DebugEvent               PROCEDURE(<STRING pDebugProcedure>)
cs_DebugString       string(600) !beware of overflow if ShowAll and ColWidths is bigger then 600
cl_Offset            LONG(1)
!cb_DebugNoCR        BYTE(0)
  MAP
    DebugEvent:Append(LONG ColWidth, STRING Str)
  END

  CODE
  IF pDebugProcedure                     THEN DebugEvent:Append(LEN(CLIP(pDebugProcedure))+1,  pDebugProcedure)                           END
	                                           DebugEvent:Append(24, SELF.GetEventDescr() ) ! EVENT() & SUB(SELF.GetEventDescr(),7,100)) !SUB() strip's off 'EVENT:'
  if self.ShowField      or self.ShowAll THEN DebugEvent:Append(34,      'Field('& SELF.GetFEQDescr()           &' = '& FIELD()    & ')') END
  if self.ShowFocus      or self.ShowAll THEN DebugEvent:Append(34,      'Focus('& SELF.GetFEQDescr(FOCUS())    &' = '& FOCUS()    & ')') END
  if self.ShowSelected   or self.ShowAll THEN DebugEvent:Append(34,   'Selected('& SELF.GetFEQDescr(SELECTED()) &' = '& SELECTED() & ')') END
  if self.ShowSelStart   or self.ShowAll THEN DebugEvent:Append(14,   'SelStart('& FOCUS(){prop:SelStart}                          & ')') END
  if self.ShowSelEnd     or self.ShowAll THEN DebugEvent:Append(14,     'SelEnd('& FOCUS(){prop:SelEnd}                            & ')') END
  if self.ShowKeyCode    or self.ShowAll THEN DebugEvent:Append(14,    'KeyCode('& KEYCODE()                                       & ')') END
  if self.ShowError      or self.ShowAll THEN DebugEvent:Append(24,      'Error('& ERRORCODE() & ': ' & CLIP(ERROR())              & ')') END
  if self.ShowThread     or self.ShowAll THEN DebugEvent:Append(14,     'Thread('& THREAD()                                        & ')') END
  if self.ShowAcceptAll  or self.ShowAll THEN DebugEvent:Append(14,  'AcceptAll('& 0{prop:AcceptAll}                               & ')') END
  if self.ShowContents   or self.ShowAll THEN DebugEvent:Append(24,   'Contents('& CONTENTS(FOCUS())                               & ')') END
  if self.ShowScreenText or self.ShowAll THEN DebugEvent:Append(50, 'ScreenText('& FOCUS(){prop:ScreenText}                        & ')') END
                                                              !294 + pDebugProcedure width
  !cb_DebugNoCR   = SELF.DebugNoCR
  !SELF.DebugNoCR = TRUE                        !<-- Threading bug
     SELF.Debug(cs_DebugString[1:cl_Offset])
  !SELF.DebugNoCR = cb_DebugNoCR

DebugEvent:Append  PROCEDURE(LONG ColWidth, STRING Str)	!Local to .DebugEvent
  CODE
!? ASSERT(ColWidth > 0,'DebugEvent:Append ColWidith['& ColWidth &'] is must be positive')
 ! cs_DebugString = cs_DebugString[1:cl_Offset] & Str !<--- InEfficient
  cs_DebugString[cl_Offset : cl_Offset + ColWidth - 1] = Str
  cl_Offset += ColWidth


  !Region DEBUGER Methods  
!==============================================================================
UltimateDebugCore.DebugOut                 PROCEDURE(STRING pDebugString)
  CODE
  SELF.Debug(pDebugString)
  RETURN

!==============================================================================
UltimateDebugCore.DumpGroup                PROCEDURE(*GROUP xaGroup, STRING xLinePrefix)
_What      ANY
_Where     LONG(1)
!CurrDim   LONG         !<--- C61 + support HOWMANY
! We limit the amount of bytes that we dump for each field to a maximum number to not display
! too much data that is really not necessary to identify what is actually in the field.
! The last thing you really need is to display a string field that is 10,000 characters long.
! You get the type and length of the field and that should allow you to identify everything.
_Type      LONG(0)
_Size      LONG(0)
_Data      CSTRING(31)  ! Limit the amount of data to show
  CODE
  LOOP
    _What  &= WHAT(xaGroup,_Where)
    IF _What &= NULL
       BREAK
    END

	_Type = SELF.GetVarType(_What)
	_Size = SELF.GetVarSize(_What)

    IF ISGROUP(xaGroup,_Where)
      SELF.DebugOut(xLinePrefix & ' ' & WHO(xaGroup,_Where) & ' (' & _Type & ') ' & SELF.DescribeDataType(_Type) & '(' & _Size & ')')
      _Where += 1
	  CYCLE
	END
	
    ! These are dealt with automatically
	                     _Data = _What
	! Handle the special cases				 
	CASE _Type
    OF DataType:DATE   ; _Data = CLIP(FORMAT(_What,@D010-B))
	OF DataType:TIME   ; _Data = CLIP(FORMAT(_What,@T04B))
	OF DataType:STRING ; _Data = CLIP       (_What)
	END
	
    SELF.DebugOut(xLinePrefix & ' ' & WHO(xaGroup,_Where) & ' (' & _Type & ') ' & SELF.DescribeDataType(_Type) & '(' & _Size & ') = [<39>' & _Data & '<39>]')

    _Where += 1
  END
  RETURN
!==============================================================================
UltimateDebugCore.GetVarSize                PROCEDURE(*? xaVar) !,LONG
UFO                             &TUFO_CallInterface
  CODE
  UFO &= ADDRESS(xaVar)
  RETURN UFO._Size( ADDRESS(xaVar) ) 
!==============================================================================
UltimateDebugCore.GetVarType                PROCEDURE(*? xaVar) !,LONG
!--- see softvelocity.public.clarion6 "Variable Data Type" Sept,12,2006 (code posted by dedpahom) -----!
!--- the following links are in Clarion and RUSSIAN -- can we get a translation please!
!http://www.clarionlife.net/content/view/159/29/
!http://www.clarionlife.net/content/view/153/29/
!translated pages seem to say that this will GPF in C50, but is ok in C55
UFO                             &TUFO_CallInterface
  CODE 
  ! COMPILE('***',_C70_) 
  !   MESSAGE('debuger.GetVarType has not been implemented')
  !   RETURN 0
  ! !END-COMPILE('***',_C70_)
    
  ! OMIT('***',_C70_)
  UFO &= ADDRESS(xaVar)
  RETURN UFO._Type( ADDRESS(xaVar) ) 
  !RETURN UFO._Type() !(42) !<-- my guess is that this arg. is ignored. -- confirmed
  !END-OMIT('***',_C70_)
!==============================================================================
UltimateDebugCore.DescribeDataType            PROCEDURE(LONG xType) !,STRING  !<-- assumes a DATATYPE:*  (see equates.clw)
RetVal CSTRING(25) !DataType:PDECIMAL has a length of 17
  CODE
  CASE xType                                               ! ITEMIZE(1),PRE(DataType)
    OF DataType:BYTE     ; RetVal = 'DataType:BYTE'         ! EQUATE
    OF DataType:SHORT    ; RetVal = 'DataType:SHORT'        ! EQUATE
    OF DataType:USHORT   ; RetVal = 'DataType:USHORT'       ! EQUATE
    OF DataType:DATE     ; RetVal = 'DataType:DATE'         ! EQUATE
    OF DataType:TIME     ; RetVal = 'DataType:TIME'         ! EQUATE
    OF DataType:LONG     ; RetVal = 'DataType:LONG'         ! EQUATE
    OF DataType:ULONG    ; RetVal = 'DataType:ULONG'        ! EQUATE
    OF DataType:SREAL    ; RetVal = 'DataType:SREAL'        ! EQUATE
    OF DataType:REAL     ; RetVal = 'DataType:REAL'         ! EQUATE
    OF DataType:DECIMAL  ; RetVal = 'DataType:DECIMAL'      ! EQUATE
    OF DataType:PDECIMAL ; RetVal = 'DataType:PDECIMAL'     ! EQUATE
    OF DataType:BFLOAT4  ; RetVal = 'DataType:BFLOAT4'      ! EQUATE(13)
    OF DataType:BFLOAT8  ; RetVal = 'DataType:BFLOAT8'      ! EQUATE
    OF DataType:STRING   ; RetVal = 'DataType:STRING'       ! EQUATE(18)
    OF DataType:CSTRING  ; RetVal = 'DataType:CSTRING'      ! EQUATE
    OF DataType:PSTRING  ; RetVal = 'DataType:PSTRING'      ! EQUATE
    OF DataType:MEMO     ; RetVal = 'DataType:MEMO'         ! EQUATE
    OF DataType:BLOB     ; RetVal = 'DataType:BLOB'         ! EQUATE(27)
  ELSE                   ; RetVal = 'Unknown['& xType &']'
                           !31 seems to be returned for references (and ANY)  (c6.9056)
  END
  RETURN RetVal
!==============================================================================
UltimateDebugCore.DescribeType                PROCEDURE(LONG xType)
RetVal CSTRING(25)
CREATE:_ComboButton   EQUATE(CREATE:combo + 0100H)  !see NG:  Softvelocity.clarion.documentation  Thread:"What is {prop:type}=271"  Sept-18-2006
  CODE
  CASE xType
    OF CREATE:sstring      ; RetVal = 'create:SSTRING'
    OF CREATE:string       ; RetVal = 'create:STRING'
    OF CREATE:image        ; RetVal = 'create:IMAGE'
    OF CREATE:region       ; RetVal = 'create:REG' & 'ION' !hopefully R E G I O N won't trigger the code folding bugs
    OF CREATE:line         ; RetVal = 'create:LINE'
    OF CREATE:box          ; RetVal = 'create:BOX'
    OF CREATE:ellipse      ; RetVal = 'create:ELLIPSE'
    OF CREATE:entry        ; RetVal = 'create:ENTRY'
    OF CREATE:button       ; RetVal = 'create:BUTTON'
    OF CREATE:prompt       ; RetVal = 'create:PROMPT'
    OF CREATE:option       ; RetVal = 'create:OPTION'
    OF CREATE:check        ; RetVal = 'create:CHECK'
    OF CREATE:group        ; RetVal = 'create:GROUP'
    OF CREATE:list         ; RetVal = 'create:LIST'
    OF CREATE:combo        ; RetVal = 'create:COMBO'
    OF CREATE:spin         ; RetVal = 'create:SPIN'
    OF CREATE:text         ; RetVal = 'create:TEXT'
    OF CREATE:custom       ; RetVal = 'create:CUSTOM'
    OF CREATE:menu         ; RetVal = 'create:MENU'
    OF CREATE:item         ; RetVal = 'create:ITEM'
    OF CREATE:radio        ; RetVal = 'create:RADIO'
    OF CREATE:menubar      ; RetVal = 'create:MENUBAR'
    OF CREATE:application  ; RetVal = 'create:APPLICATION'
    OF CREATE:window       ; RetVal = 'create:WINDOW'
    OF CREATE:report       ; RetVal = 'create:REPORT'
    OF CREATE:header       ; RetVal = 'create:HEADER'
    OF CREATE:footer       ; RetVal = 'create:FOOTER'
    OF CREATE:break        ; RetVal = 'create:BREAK'
    OF CREATE:form         ; RetVal = 'create:FORM'
    OF CREATE:detail       ; RetVal = 'create:DETAIL'
    OF CREATE:ole          ; RetVal = 'create:OLE'
    OF CREATE:droplist     ; RetVal = 'create:DROPLIST'
    OF CREATE:dropcombo    ; RetVal = 'create:DROPCOMBO'
    OF CREATE:progress     ; RetVal = 'create:PROGRESS'
    OF CREATE:sheet        ; RetVal = 'create:SHEET'
    OF CREATE:tab          ; RetVal = 'create:TAB'
    OF CREATE:panel        ; RetVal = 'create:PANEL'
                                                   COMPILE('**++** _C60_Only_',_C60_)
    OF CREATE:rtf          ; RetVal = 'create:RTF'
                                              !END-COMPILE('**++** _C60_Only_',_C60_)
    OF CREATE:sublist      ; RetVal = 'create:SUBLIST'     ! found via  ?Combo_or_List_WithDrop{prop:ListFEQ)
    OF CREATE:toolbar      ; RetVal = 'create:TOOLBAR'
    OF CREATE:_ComboButton ; RetVal = 'create:COMBOBUTTON' ! UN-OFFICIAL the control found via: ?Combo{prop:ButtonFEQ}
  ELSE                     ; RetVal = 'Unknown['& xType &']'
  END
  RETURN RetVal
!==============================================================================
UltimateDebugCore.DumpRecord                  PROCEDURE(*FILE pFile,STRING xLinePrefix)
G           &GROUP
	CODE
	                                       COMPILE('!ENDCOMPILE', ST::DEBUG:Debugging=1)
	IF SELF.DebugOff THEN RETURN END
	G &= pFile{PROP:Record}
	SELF.DebugOut('DumpRecord(<39>' & NAME(pFile) & '<39>)')
	SELF.DumpGroup(G, xLinePrefix)
	                                       !ENDCOMPILE
	RETURN

!==============================================================================
!==============================================================================
!==============================================================================
UltimateDebugCore.DumpGroupWindow             PROCEDURE(*GROUP pGroup)
  CODE
  SELF.DumpGroupWindow(pGroup,'')
  RETURN
!==============================================================================
UltimateDebugCore.DumpRecordWindow            PROCEDURE(*FILE pFile)
  CODE
  SELF.DumpRecordWindow(pFile,'')
  RETURN
!==============================================================================	
UltimateDebugCore.DumpRecordWindow            PROCEDURE(*FILE pFile,STRING xMsg,<STRING pStructureType>)
G           &GROUP
	CODE
	                                       COMPILE('!ENDCOMPILE', ST::DEBUG:Debugging=1)
	IF SELF.DebugOff THEN RETURN END
	G &= pFile{PROP:Record}
	SELF.DumpGroupWindow(G, xMsg, CHOOSE(pStructureType='', NAME(pFile), NAME(pFile) & ' ' & pStructureType))
	                                       !ENDCOMPILE
	RETURN
!==============================================================================
UltimateDebugCore.DumpGroupWindow             PROCEDURE(*GROUP pGroup,STRING pMsg,<STRING pStructureType>)
SavePointer   LONG,AUTO
NumFields     SHORT(0)
!NumFields2    SHORT(0)
FieldQ        QUEUE
Name            CSTRING(101)
Type            CSTRING(256) !(1000) !Shortened to match PROP:Format
Value           CSTRING(256) !(1000) !Shortened to match PROP:Format
              END
MsgLineQ      QUEUE
Text            STRING(100)
              END
!------------------------------------------------------------------------------
Window        WINDOW('Debug'),AT(,,676,416),FONT('Segoe UI',10,,),CENTER,SYSTEM,GRAY,DOUBLE
                LIST,AT(4,4,668,356),USE(?DebugList),VSCROLL,FROM(FieldQ),FORMAT(|
                  '180L(2)|M~Field Name~S(1)@S100@' & |
                  '120L(2)|M~Type~S(1)@S255@'      & |
                  '1000L(2)|M~Value~S(1)@S255@')
                LIST,AT(4,364,668,48),USE(?MessageList),VSCROLL,FROM(MsgLineQ)
              END
!------------------------------------------------------------------------------
	CODE
                                    	COMPILE('!ENDCOMPILE', ST::DEBUG:Debugging=1)
	IF SELF.DebugOff THEN RETURN END
	DO LoadFieldQ
	!--- Prepare window
	OPEN(Window)
	0{PROP:Text} = 0{PROP:Text} &' '& CHOOSE(pStructureType='', 'Group', pStructureType) &' ('& NumFields &' Fields)'
	IF pMsg
		SELF.FormatMessageList(pMsg, MsgLineQ)
	ELSE
		HIDE(?MessageList)
		?DebugList{PROP:Height} = ?DebugList{PROP:Height} + ?MessageList{PROP:Height} + 4
	END
	!--- Display window
	ACCEPT
	END
	                                          !ENDCOMPILE
	RETURN
!======================================
LoadFieldQ                      ROUTINE
	DATA
!F       ANY                  !Field reference for value assignment
X       SHORT,AUTO
M       SHORT(0)
_What      ANY                  !Field reference for value assignment
_Type      LONG(0)
_Size      LONG(0)
_Data      CSTRING(31)
  CODE
	LOOP X = 10000 TO 1 BY -1
		IF NumFields = 0 AND WHO(pGroup, X) <> ''
			NumFields = X
			IF M = 0
				M = NumFields
			END
		END
		IF M = 0 AND NumFields
			M = X
		END
		IF NumFields
			BREAK
		END
	END
	LOOP X = 1 TO M
		CLEAR(FieldQ)
		IF NumFields >= X
      FieldQ.Name   = WHO(pGroup, X)
!      F            &= WHAT(pGroup, X, 1)
      _What        &= WHAT(pGroup, X, 1)
!     _Type         = SELF.GetVarType(F)
!     _Size         = SELF.GetVarSize(F)
      _Type         = SELF.GetVarType(_What)
      _Size         = SELF.GetVarSize(_What)
		  FieldQ.Type   = SELF.DescribeDataType(_Type) & '(' & _Size & ')'
      IF NOT ISGROUP(pGroup, X)
!                              _Data = F
!        CASE _Type
!        OF DataType:DATE   ;  _Data = CLIP(FORMAT(F,@D010-B))
!        OF DataType:TIME   ;  _Data = CLIP(FORMAT(F,@T04B))
!        OF DataType:STRING ;  _Data = CLIP       (F)
!        END   
                              _Data = _What
        CASE _Type
        OF DataType:DATE   ;  _Data = CLIP(FORMAT(_What,@D010-B))
        OF DataType:TIME   ;  _Data = CLIP(FORMAT(_What,@T04B))
        OF DataType:STRING ;  _Data = CLIP       (_What)
        END
        FieldQ.Value        = _Data
      END
		END
		ADD(FieldQ)
		ASSERT(ERRORCODE()=0)
	END
  EXIT
!==============================================================================
UltimateDebugCore.FormatMessageList           PROCEDURE(STRING pMsg,*QUEUE pMsgQueue)
StartPos                            LONG(1)
Pos                                 LONG,AUTO
  CODE
	IF pMsg
		LOOP WHILE StartPos
			Pos = INSTRING('|', pMsg, 1, StartPos)
			pMsgQueue = CHOOSE(Pos=0, pMsg[StartPos : LEN(pMsg)], pMsg[StartPos : Pos-1])
			ADD(pMsgQueue)
			ASSERT(ERRORCODE()=0)
			StartPos = Pos+1
		UNTIL Pos = 0
	END
  RETURN
	
!==============================================================================
!EndRegion DEBUGER Methods

  
!EndRegion UltimateDebugCore  
  
!Region UltimateDebug

!==============================================================================
UltimateDebug.Init                     PROCEDURE()
	CODE
    RETURN
!==============================================================================
UltimateDebug.Kill                     PROCEDURE()
	CODE
	RETURN
!==============================================================================
UltimateDebug.GetCategory              PROCEDURE(STRING pCategory)!,BOOL
	CODE
  IF (SELF.DebugMe) THEN
    SELF.RawODS('DEBUGME: UltimateDebug.GetCategory')
  END

	SELF.CategoryQueue.Category = pCategory
	GET(SELF.CategoryQueue,SELF.CategoryQueue.Category)
  RETURN CHOOSE( ERRORCODE() = 0 )
!==============================================================================
UltimateDebug.AddCategoryToDebug       PROCEDURE(STRING pCategory) !Used to Filter Messages not belonging to active Categories
	CODE
   IF ~ SELF.GetCategory(pCategory)
      SELF.CategoryQueue.Category = pCategory
	   ADD(SELF.CategoryQueue,SELF.CategoryQueue.Category)
	END
!==============================================================================
UltimateDebug.Debug                    PROCEDURE(STRING pCategory,STRING pDebugString)
	CODE
   IF SELF.GetCategory(pCategory)
		SELF.Debug('[' & CLIP(pCategory) & ']' & pDebugString)
	END
!==============================================================================
UltimateDebug.DebugEntry               PROCEDURE(STRING pCategory,STRING pDebugString)
!==============================================================================
    CODE
   IF SELF.GetCategory(pCategory)
		SELF.DebugEntry('[' & CLIP(pCategory) & ']' & pDebugString)
	END
    RETURN
!==============================================================================
UltimateDebug.DebugLevel               PROCEDURE(STRING pCategory,STRING pDebugString)
!==============================================================================
    CODE
   IF SELF.GetCategory(pCategory)
		SELF.DebugLevel('[' & CLIP(pCategory) & ']' & pDebugString)
	END
    RETURN
!==============================================================================
UltimateDebug.DebugExit                PROCEDURE(STRING pCategory,STRING pDebugString)
!==============================================================================
    CODE
   IF SELF.GetCategory(pCategory)
		SELF.DebugExit('[' & CLIP(pCategory) & ']' & pDebugString)
	END
    RETURN
!==============================================================================
UltimateDebug.DebugRecord              PROCEDURE(*FILE pFile,STRING pMsg)
G                                   &GROUP
	CODE
	                                       COMPILE('!ENDCOMPILE', ST::DEBUG:Debugging=1)
	IF SELF.DebugOff THEN RETURN END
	G &= pFile{PROP:Record}
	SELF.DebugGroup(G,, pMsg, 'Record')
	                                       !ENDCOMPILE
	RETURN
!==============================================================================
UltimateDebug.DebugRecord              PROCEDURE(*FILE pFile,*FILE pFile2,STRING pMsg)
G1                                  &GROUP
G2                                  &GROUP
	CODE
                                    	      COMPILE('!ENDCOMPILE', ST::DEBUG:Debugging=1)
	IF SELF.DebugOff THEN RETURN END
	G1 &= pFile {PROP:Record}
	G2 &= pFile2{PROP:Record}
	SELF.DebugGroup(G1, G2, pMsg, 'Record')
	                                         !ENDCOMPILE
	RETURN
!==============================================================================
UltimateDebug.DebugGroup               PROCEDURE(*GROUP pGroup,STRING pMsg,<STRING pStructureType>)
	CODE
	                                       COMPILE('!ENDCOMPILE', ST::DEBUG:Debugging=1)
	IF SELF.DebugOff THEN RETURN END
	SELF.DebugGroup(pGroup,, pMsg)
	                                       !ENDCOMPILE
	RETURN
!==============================================================================
UltimateDebug.DebugGroup               PROCEDURE(*GROUP pGroup,<*GROUP pGroup2>,STRING pMsg,<STRING pStructureType>)
epGroup2                            EQUATE(2)
SavePointer                         LONG,AUTO
NumFields                           SHORT(0)
NumFields2                          SHORT(0)
FieldQ                     QUEUE
Name                                CSTRING(101)
Value                               CSTRING(256) !(1000) !Shortened to match PROP:Format
Value2                              CSTRING(256) !(1000) !Shortened to match PROP:Format
									END
MsgLineQ                   QUEUE
Text                                STRING(100)
									END
!--------------------------------------
Window    WINDOW('Debug'),AT(,,676,416),FONT('Tahoma',8,,),CENTER,SYSTEM,GRAY,DOUBLE
				LIST,AT(4,4,668,356),USE(?DebugList),VSCROLL,FROM(FieldQ),FORMAT(|
				      '125L(2)|M~Field Name~S(1)@S100@' & |
				      '180L(2)|M~Value~S(1)@S255@'      & |
				     '1000L(2)|M~Value2~S(1)@S255@')
				LIST,AT(4,364,668,48),USE(?MessageList),VSCROLL,FROM(MsgLineQ)
			 END
!--------------------------------------
	CODE
                                    	COMPILE('!ENDCOMPILE', ST::DEBUG:Debugging=1)
	IF SELF.DebugOff THEN RETURN END
	DO LoadFieldQ
	!--- Prepare window
	OPEN(Window)
	IF OMITTED(epGroup2)
		?DebugList{PROPLIST:Width, 2} = 1000
	END
	0{PROP:Text} = 0{PROP:Text} &' '& CHOOSE(pStructureType='', 'Group', pStructureType) &' ('& NumFields &' Fields)'
	IF pMsg
		SELF.FormatMessageList(pMsg, MsgLineQ)
	ELSE
		HIDE(?MessageList)
		?DebugList{PROP:Height} = ?DebugList{PROP:Height} + ?MessageList{PROP:Height} + 4
	END
	!--- Display window
	ACCEPT
	END
	                                          !ENDCOMPILE
	RETURN
!======================================
LoadFieldQ                      ROUTINE
	DATA
F       ANY                  !Field reference for value assignment
X       SHORT,AUTO
M       SHORT(0)
	CODE
!!	OMIT('!+++!!!+++!')
	LOOP X = 10000 TO 1 BY -1
		IF NumFields = 0 AND WHO(pGroup, X) <> ''
			NumFields = X
			IF M = 0
				M = NumFields
			END
		END
		IF NOT OMITTED(epGroup2)  |
				AND NumFields2 = 0 AND WHO(pGroup2, X) <> ''
			NumFields2 = X
			IF M = 0
				M = NumFields2
			END
		END
		IF M = 0 AND (NumFields OR NumFields2)
			M = X
		END
		IF NumFields AND (OMITTED(epGroup2) OR NumFields2)
			BREAK
		END
	END
	LOOP X = 1 TO M
		CLEAR(FieldQ)
		IF NumFields >= X
			FieldQ.Name   = WHO(pGroup, X)
			F            &= WHAT(pGroup, X, 1)
	IF NOT ISGROUP(pGroup, X)
			FieldQ.Value  = F
	END
			IF NumFields2 >= X
				DO AssignValue2
			END
		ELSE
			FieldQ.Name   = WHO(pGroup2, X)
			DO AssignValue2
		END
		ADD(FieldQ)
		ASSERT(ERRORCODE()=0)
	END
!!	!+++!!!+++!
	EXIT
!======================================
AssignValue2                    ROUTINE
!--------------------------------------
	                                       OMIT('!+++!!!+++!')
	F &= WHAT(pGroup2, X, 1)
	FieldQ.Value2 = F
	                                       !+++!!!+++!
	EXIT
!==============================================================================
UltimateDebug.DebugQueue               PROCEDURE(*QUEUE pQueue,<STRING pMsg>,<BYTE pNoTouch>)
								MAP
DebugQueue:LoadFieldQ                          PROCEDURE
								END
!--------------------------------------
SavePointer                         LONG,AUTO
NumFields                           SHORT,AUTO
									COMPILE('***---***', E_StripPrefix)
!StripPrefixLength   BYTE,AUTO
									***---***
FieldQ                              QUEUE
Header                                  CSTRING(100)
Width                                   LONG
IsNumeric                               BOOL
IsGroup                                 BOOL
									END
MsgLineQ                            QUEUE
Text                                    STRING(1000)
									END
!--------------------------------------
Window    WINDOW('Debug Queue'),SYSTEM,AT(,,676,416),CENTER,FONT('Tahoma', 8),GRAY,DOUBLE
										LIST, AT(4,4,668,356), USE(?DebugList), HVSCROLL
										LIST, AT(4,364,668,48), USE(?MessageList), VSCROLL, FROM(MsgLineQ)
									END
!--------------------------------------
	CODE
	                                                                                          COMPILE('!ENDCOMPILE', ST::DEBUG:Debugging=1)
	IF SELF.DebugOff THEN RETURN END
	IF pQueue &= NULL
		MESSAGE('Queue passed to ST::DebugQueue was a NULL pointer!', 'Debug Queue')
	ELSE
		!--- Save current queue pointer
		SavePointer = CHOOSE(RECORDS(pQueue)=0, 0, POINTER(pQueue))
		!--- Scan passed queue
		DO FindLastField
		IF NumFields = 0
			MESSAGE('Queue passed to ST::DebugQueue has no fields!', 'Debug Queue')
		ELSE
			                        COMPILE('***---***', E_StripPrefix)
			DO CheckStripPrefix
			                                 ***---***
			DebugQueue:LoadFieldQ()
			!--- Prepare window
			OPEN(Window)
			0{PROP:Text} = 0{PROP:Text} &' ('& NumFields &' Fields, '& RECORDS(pQueue) &' Records)'
			DO FormatFieldList
			IF pMsg
				SELF.FormatMessageList(pMsg, MsgLineQ)
			ELSE
				HIDE(?MessageList)
				?DebugList{PROP:Height} = ?DebugList{PROP:Height} + ?MessageList{PROP:Height} + 4
			END
			!--- Display window
			ACCEPT
			END
			!--- Restore queue pointer
			IF SavePointer <> 0 AND pNoTouch <> 1
				GET(pQueue, SavePointer)
			END
		END
	END
	                                                                                                           !ENDCOMPILE
	RETURN
!======================================
FindLastField                   ROUTINE
!--------------------------------------
	NumFields = 5000
	LOOP WHILE NumFields > 0  |
			AND   WHO(pQueue, NumFields) = ''
		NumFields -= 1
	END
	EXIT

	!Consider this instead: (Also consider Binary searches, vs. += 1)
!	NumFields = 0
!	LOOP
!	  NumFields += 1
!	  IF WHAT(pQueue, NumFields) &= NULL THEN BREAK END
!	END
!	NumFields -= 1

!**************************************
	COMPILE('***---***', E_StripPrefix)
!======================================
CheckStripPrefix                ROUTINE
!--------------------------------------
	DATA
FieldNo SHORT,AUTO
PrefixFound     CSTRING(20)
!--------------------------------------
	CODE
	LOOP FieldNo = 1 TO NumFields
		FieldQ.Header = WHO(pQueue, FieldNo)
		StripPrefixLength = INSTRING(':', FieldQ.Header)
		IF StripPrefixLength
			IF FieldNo = 1
				PrefixFound = FieldQ.Header[1:S]
			ELSIF FieldQ.Header[1:S] <> PrefixFound
				StripPrefixLength = 0
				BREAK
			END
		ELSIF PrefixFound
			StripPrefixLength = 0
			BREAK
		END
	END
	EXIT
	***---***
!======================================
FormatFieldList                 ROUTINE
!--------------------------------------
	DATA
FieldNo SHORT,AUTO
ColumnNo        SHORT(0)
!--------------------------------------
	CODE
	?DebugList{PROP:From} = pQueue
	?DebugList{PROP:Selected} = SavePointer
	LOOP FieldNo = 1 TO NumFields
		GET(FieldQ, FieldNo)
		IF FieldQ.IsGroup
			CYCLE
		END
		ColumnNo += 1
		?DebugList{PROPLIST:Header                    , ColumnNo} = FieldQ.Header
		?DebugList{PROPLIST:Picture    +PROPLIST:Group, ColumnNo} = '@S'& FieldQ.Width
		?DebugList{PROPLIST:RightBorder+PROPLIST:Group, ColumnNo} = 1
		?DebugList{PROPLIST:Resize                    , ColumnNo} = 1
		?DebugList{PROPLIST:Width                     , ColumnNo} = FieldQ.Width
		?DebugList{PROPLIST:HeaderCenter              , ColumnNo} = True
!   ?DebugList{PROPLIST:HeaderLeft                , ColumnNo} = True
!   ?DebugList{PROPLIST:HeaderLeftOffset          , ColumnNo} = 1
		IF FieldQ.IsNumeric
			?DebugList{PROPLIST:Right                   , ColumnNo} = True
			?DebugList{PROPLIST:RightOffset             , ColumnNo} = 1
		ELSE
			?DebugList{PROPLIST:Left                    , ColumnNo} = True
			?DebugList{PROPLIST:LeftOffset              , ColumnNo} = 1
		END
		?DebugList{PROPLIST:FieldNo                   , ColumnNo} = FieldNo
	END
	!ST::Debug(?DebugList{PROP:Format})
	EXIT
!==============================================================================
DebugQueue:LoadFieldQ                            PROCEDURE
!--------------------------------------
FieldNo                             SHORT,AUTO
FieldRef                            ANY
RecNo                               LONG,AUTO
SampleLength                        LONG,AUTO
HeaderLength                        LONG,AUTO
DataLength                          LONG,AUTO
IsDataUpper                         BOOL,AUTO
!--------------------------------------
	CODE
	!ST::Debug('ST::DebugQueue/LoadFieldQ/IN: NumFields='& NumFields)
	LOOP FieldNo = 1 TO NumFields
		CLEAR(FieldQ)
		!ST::Debug('ST::DebugQueue/LoadFieldQ: FieldNo='& FieldNo)
		FieldQ.Header                  = LOWER(WHO(pQueue, FieldNo))
		COMPILE('***---***', E_StripPrefix)
		IF StripPrefixLength
			HeaderLength                 = LEN(FieldQ.Header) - StripPrefixLength
			FieldQ.Header                = SUB(FieldQ.Header, StripPrefixLength+1, HeaderLength)
		ELSE
			***---***
			HeaderLength                 = LEN(FieldQ.Header)
			COMPILE('***---***', E_StripPrefix)
		END
		***---***
		IF HeaderLength < 1
			HeaderLength                 = 1
		END
		COMPILE('***---***', _C60_)
		FieldRef                      &= WHAT(pQueue, FieldNo, 1)
		***---***
		OMIT('***---***', _C60_)
		FieldRef                      &= WHAT(pQueue, FieldNo)
		***---***
		FieldQ.IsGroup                 = ISGROUP(pQueue, FieldNo)
		FieldQ.IsNumeric               = TRUE
		IsDataUpper                    = FALSE
		!ST::Debug('ST::DebugQueue/LoadFieldQ: RECORDS(pQueue)='& RECORDS(pQueue))
		IF RECORDS(pQueue) > 0 AND pNoTouch <> 1
			DataLength                   = 0
			LOOP RecNo = 1 TO RECORDS(pQueue)
				GET(pQueue, RecNo)
				!ST::Debug('ST::DebugQueue/LoadFieldQ: RecNo='& RecNo &'; FieldRef='& FieldRef)
				IF FieldRef <> ''
					IF NOT NUMERIC(FieldRef)
						FieldQ.IsNumeric       = FALSE
					END
					SampleLength = LEN(CLIP(FieldRef))
					IF NOT FieldQ.IsNumeric AND UPPER(FieldRef) = FieldRef
						IsDataUpper            = TRUE
					END
					IF SampleLength > 25
						DataLength             = 25
					ELSIF DataLength < SampleLength
						DataLength             = SampleLength
					END
				END
			END
		ELSE
			IsDataUpper                  = TRUE
			FieldQ.IsNumeric             = FALSE
			DataLength                   = LEN(FieldRef)
		END
		DO CalculateColumnWidth
		ADD(FieldQ)
	END
	!ST::Debug('ST::DebugQueue/LoadFieldQ/OUT')

CalculateColumnWidth            ROUTINE
	DATA
HeaderWidth     SHORT,AUTO
DataWidth       SHORT,AUTO
	CODE
	HeaderWidth  = HeaderLength * WidthMultiplier:Narrow
	DataWidth    = DataLength * CHOOSE(~IsDataUpper, WidthMultiplier:Narrow, WidthMultiplier:Wide)
	FieldQ.Width = CHOOSE(DataWidth > HeaderWidth, DataWidth, HeaderWidth)
	!ST::Debug(FieldQ.Header &' - '& HeaderLength &' - '& DataLength &' - '& HeaderWidth &' - '& DataWidth &' - '& FieldQ.Width)
!==============================================================================
UltimateDebug.Message                  PROCEDURE(STRING pDebugString)
    CODE
    SELF.Debug(pDebugString)
!==============================================================================
UltimateDebug.SetApplicationName       PROCEDURE(STRING pApplicationName,STRING pProgramExtension)    !,STRING
ApplicationName   STRING(50)
  CODE
  CASE UPPER(CLIP(pProgramExtension))
    OF 'EXE' ;  ApplicationName = 'Application  <9>' & pApplicationName & '.EXE'
    OF 'DLL' ;  ApplicationName = 'DLL          <9>' & pApplicationName & '.DLL'
    OF 'LIB' ;  ApplicationName = 'Library      <9>' & pApplicationName & '.LIB'
  END
  RETURN ApplicationName
!==============================================================================
UltimateDebug.SetShortApplicationName  PROCEDURE(STRING pApplicationName,STRING pProgramExtension)    !,STRING
ApplicationName   STRING(50)
  CODE
  CASE UPPER(CLIP(pProgramExtension))
    OF 'EXE' ;  ApplicationName = pApplicationName & '.EXE'
    OF 'DLL' ;  ApplicationName = pApplicationName & '.DLL'
    OF 'LIB' ;  ApplicationName = pApplicationName & '.LIB'
  END
  RETURN ApplicationName
  !Consider   !RETURN pApplicationName & '.' & pProgramExtension
!==============================================================================
UltimateDebug.ShowProcedureInfo        PROCEDURE(STRING pProcedure,STRING pApplication,STRING pHelpID,STRING pCreated,STRING pModified,STRING pCompiled)
!TheStats                               ANY			! RA.2014.06.04 - This does not work
TheStats				STRING(2048)            ! RA.2014.06.04 - This does work
Window                                  WINDOW('Procedure Information'),AT(,,275,121),CENTER,GRAY
                                          GROUP('Procedure Information'),AT(3,8,190,102),USE(?GROUP1),BOXED
                                          END
                                          TEXT,AT(11,20,176,84),USE(TheStats),SKIP,TRN
                                          BUTTON('Send To Clipboard'),AT(198,61,72),USE(?BUTTONToClipboard)
                                          BUTTON('Send To Debug'),AT(198,78,72),USE(?BUTTONToDebug)
                                          BUTTON('Close'),AT(198,96,72),USE(?BUTTONClose)
                                        END
  CODE
  DO ClearKeyStrokes

  TheStats = ('Procedure:<9>'  & CLIP(pProcedure)   & '<13,10>'          & |
                                 CLIP(pApplication) & '<13,10><13,10>'   & |
              'Help ID    <9>' & CLIP(pHelpID)      & '<13,10>'          & |
              'Created  On<9>' & CLIP(pCreated)     & '<13,10>'          & |
              'Modified On<9>' & CLIP(pModified)    & '<13,10>'          & |
              'Compiled On<9>' & CLIP(pCompiled))
  OPEN(Window)
  ACCEPT
    CASE ACCEPTED()
      OF ?BUTTONClose         ; BREAK
      OF ?BUTTONToClipboard   ; SETCLIPBOARD(TheStats)
      OF ?BUTTONToDebug       ; Self.Debug(CLIP(TheStats))      ! RA.2014.06.04 - CLIP the string
    END
  END
  DO ClearKeyStrokes

ClearKeyStrokes ROUTINE
    LOOP WHILE KEYBOARD() !Empty the keyboard buffer
      ASK                 !without processing keystrokes
    END
    SETKEYCODE(0)
!==============================================================================
UltimateDebug.FormatMessageList        PROCEDURE(STRING pMsg,*QUEUE pMsgQueue)
   !See UltimateString.Split('|')
StartPos                            LONG(1)
Pos                                 LONG,AUTO
	CODE
	IF pMsg
		LOOP WHILE StartPos
			Pos = INSTRING('|', pMsg, 1, StartPos)
			pMsgQueue = CHOOSE(Pos=0, pMsg[StartPos : LEN(pMsg)], pMsg[StartPos : Pos-1])
			ADD(pMsgQueue)
			ASSERT(ERRORCODE()=0)
			StartPos = Pos+1
		UNTIL Pos = 0
	END
	RETURN
!==============================================================================
UltimateDebug.Construct                PROCEDURE
   CODE
   !This is a dervied class, see parent constructor
   SELF.EventQ        &= NEW ST::DebugEventQueue
   SELF.IgnoreEventQ  &= NEW ST::DebugEventQueue
   SELF.CategoryQueue &= NEW DebugCategoryQueue

!    REGISTER(EVENT:AlertKey,ADDRESS(SELF.ShowProcedureInfo),ADDRESS(SELF))
   SELF.SetPurgeTime(5*TIME:Minute)
!==============================================================================
UltimateDebug.Destruct                 PROCEDURE
	CODE
   IF ~(SELF.EventQ        &= NULL) THEN FREE(SELF.EventQ)       ; DISPOSE(SELF.EventQ)        END
   IF ~(SELF.IgnoreEventQ  &= NULL) THEN FREE(SELF.IgnoreEventQ) ; DISPOSE(SELF.IgnoreEventQ)  END
   IF ~(SELF.CategoryQueue &= NULL) THEN FREE(SELF.CategoryQueue); DISPOSE(SELF.CategoryQueue) END
!==============================================================================
UltimateDebug.SetDebugEvent            PROCEDURE(SIGNED Event)
	CODE
	SELF.DebugEvent = Event
!==============================================================================
UltimateDebug.SetHotKey                PROCEDURE(UNSIGNED HotKey)
	CODE
	0{PROP:Alrt, 255} = HotKey
	SELF.HotKey = HotKey
	SELF.SetDebugEvent(EVENT:AlertKey)
!==============================================================================
UltimateDebug.SetPurgeTime             PROCEDURE(LONG PurgeTime)
	CODE
	IF PurgeTime <= 0
		SELF.PurgeStarTime = 0
	ELSE
		SELF.PurgeStarTime = SELF.CalcStarDate(0, PurgeTime)
	END
!==============================================================================
UltimateDebug.IgnoreEvent              PROCEDURE(SIGNED Event)
X  LONG,AUTO
	CODE
  IF (SELF.DebugMe) THEN
    SELF.RawODS('DEBUGME: UltimateDebug.IgnoreEvent')
  END

	CLEAR(SELF.IgnoreEventQ)
	SELF.IgnoreEventQ.EventNo = Event
	ADD(SELF.IgnoreEventQ, SELF.IgnoreEventQ.EventNo)

	! Purge existing logged events
	LOOP X = RECORDS(SELF.EventQ) TO 1 BY -1
		GET(SELF.EventQ, X)
		IF SELF.EventQ.EventNo = Event
			DELETE(SELF.EventQ)
		END
	END
!==============================================================================
UltimateDebug.TakeEvent                PROCEDURE
	CODE
	SELF.LogEvent()

!                    !	? !UltimateDebug.Debug('UltimateDebug.TakeEvent: DebugEvent='& SELF.DebugEvent &'; Event='& EVENT() &'-'& SELF.GetEventName(EVENT()) &'; Keycode='& KEYCODE())
!                       CASE EVENT()
!                       OF   0
!                       OROF EVENT:Suspend
!                       OROF EVENT:Resume
!                    !		?   !Self.Debug('...Ignore It')
!                          !Ignore it
!
!                       OF SELF.DebugEvent
!                    !		?   !Self.Debug('...Debug Event  '& SELF.DebugEvent &'/'& EVENT:AlertKey &'  ' & KEYCODE() &'/'& SELF.HotKey)
!                          IF SELF.DebugEvent <> EVENT:AlertKey |
!                                OR KEYCODE() = SELF.HotKey
!                             SELF.Debug('')
!                          ELSE
!                             SELF.LogEvent()
!                          END
!
!                       ELSE
!                    !		?   !SELF.Debug('...Logger')
!                          IF SELF.DebugEvent <> EVENT:AlertKey     |
!                                OR EVENT()         <> EVENT:PreAlertKey  |
!                                OR KEYCODE()       <> SELF.HotKey
!                             SELF.LogEvent()
!                          END
!                       END
   RETURN
!==============================================================================
UltimateDebug.LogEvent                 PROCEDURE
_Date LONG,AUTO
_Time LONG,AUTO
	CODE
  IF (SELF.DebugMe) THEN
    SELF.RawODS('DEBUGME: UltimateDebug.LogEvent')
  END

	SELF.IgnoreEventQ.EventNo = EVENT()
	GET(SELF.IgnoreEventQ, SELF.IgnoreEventQ.EventNo)
	IF ERRORCODE() <> 0
		CLEAR(SELF.EventQ)
		_Date = TODAY()
		_Time = CLOCK()
		SELF.EventQ.Date      = FORMAT(_Date, @D10)
		SELF.EventQ.Time      = FORMAT(_Time, @T6)
		SELF.EventQ.StarDate  = SELF.CalcStarDate(_Date,_Time)
		SELF.EventQ.EventNo   = EVENT()
		SELF.EventQ.EventName = SELF.GetEventName(EVENT())
		SELF.EventQ.FieldFeq  = FIELD()
		SELF.EventQ.FieldName = SELF.GetFEQDescr(FIELD())
		SELF.EventQ.Keycode   = KEYCODE()
		ADD(SELF.EventQ, SELF.EventQ.StarDate)
	END

	IF SELF.PurgeStarTime
	   SELF.PurgeUpTo(SELF.EventQ, SELF.CalcStarDate() - SELF.PurgeStarTime)
   END
!==============================================================================
UltimateDebug.PurgeUpTo               PROCEDURE(*ST::DebugEventQueue xaQ, REAL xPurgeUpTo)  !Assumes xaQ is sorted by StarDate
  CODE
  IF (SELF.DebugMe) THEN
    SELF.RawODS('DEBUGME: UltimateDebug.PurgeUpTo')
  END

  LOOP
    GET( xaQ, 1)
    IF ERRORCODE() OR xaQ.StarDate > xPurgeUpTo THEN BREAK END
    DELETE(xaQ)
  END
!==============================================================================
UltimateDebug.CalcStarDate             PROCEDURE(<LONG D>,<LONG T>)!,REAL
	CODE
	IF OMITTED(D) THEN D = TODAY() END
	IF OMITTED(T) THEN T = CLOCK() END
	RETURN D + (T-1)/TIME:DAY
!==============================================================================
UltimateDebug.GetEventName             PROCEDURE(SIGNED Event)!,STRING
	CODE
	RETURN SELF.GetEventDescr(Event)
!	CASE Event
!
!		! Field-dependent events
!
!	OF 01H;  RETURN 'Accepted'
!	OF 02H;  RETURN 'NewSelection'
!	OF 02H;  RETURN 'ScrollUp'
!	OF 04H;  RETURN 'ScrollDown'
!	OF 05H;  RETURN 'PageUp'
!	OF 06H;  RETURN 'PageDown'
!	OF 07H;  RETURN 'ScrollTop'
!	OF 08H;  RETURN 'ScrollBottom'
!	OF 09H;  RETURN 'Locate'
!
!	OF 01H;  RETURN 'MouseDown'
!	OF 0aH;  RETURN 'MouseUp'
!	OF 0bH;  RETURN 'MouseIn'
!	OF 0cH;  RETURN 'MouseOut'
!	OF 0dH;  RETURN 'MouseMove'
!	OF 0eH;  RETURN 'VBXevent'
!	OF 0fH;  RETURN 'AlertKey'
!	OF 10H;  RETURN 'PreAlertKey'
!	OF 11H;  RETURN 'Dragging'
!	OF 12H;  RETURN 'Drag'
!	OF 13H;  RETURN 'Drop'
!	OF 14H;  RETURN 'ScrollDrag'
!	OF 15H;  RETURN 'TabChanging'
!	OF 16H;  RETURN 'Expanding'
!	OF 17H;  RETURN 'Contracting'
!	OF 18H;  RETURN 'Expanded'
!	OF 19H;  RETURN 'Contracted'
!	OF 1AH;  RETURN 'Rejected'
!	OF 1BH;  RETURN 'DroppingDown'
!	OF 1CH;  RETURN 'DroppedDown'
!	OF 1DH;  RETURN 'ScrollTrack'
!	OF 1EH;  RETURN 'ColumnResize'
!
!	OF 101H;  RETURN 'Selected'
!	OF 102H;  RETURN 'Selecting'
!
!		! Field-independent events (FIELD() returns 0)
!
!	OF 201H;  RETURN 'CloseWindow'
!	OF 202H;  RETURN 'CloseDown'
!	OF 203H;  RETURN 'OpenWindow'
!	OF 204H;  RETURN 'OpenFailed'
!	OF 205H;  RETURN 'LoseFocus'
!	OF 206H;  RETURN 'GainFocus'
!
!	OF 208H;  RETURN 'Suspend'
!	OF 209H;  RETURN 'Resume'
!	OF 20AH;  RETURN 'Notify'
!
!	OF 20BH;  RETURN 'Timer'
!	OF 20CH;  RETURN 'DDErequest'
!	OF 20DH;  RETURN 'DDEadvise'
!	OF 20EH;  RETURN 'DDEdata'
!	OF 20FH;  RETURN 'DDEexecute'
!	OF 210H;  RETURN 'DDEpoke'
!	OF 211H;  RETURN 'DDEclosed'
!
!	OF 220H;  RETURN 'Move'
!	OF 221H;  RETURN 'Size'
!	OF 222H;  RETURN 'Restore'
!	OF 223H;  RETURN 'Maximize'
!	OF 224H;  RETURN 'Iconize'
!	OF 225H;  RETURN 'Completed'
!	OF 230H;  RETURN 'Moved'
!	OF 231H;  RETURN 'Sized'
!	OF 232H;  RETURN 'Restored'
!	OF 233H;  RETURN 'Maximized'
!	OF 234H;  RETURN 'Iconized'
!	OF 235H;  RETURN 'Docked'
!	OF 236H;  RETURN 'Undocked'
!
!	OF 240H;  RETURN 'BuildFile'
!	OF 241H;  RETURN 'BuildKey'
!	OF 242H;  RETURN 'BuildDone'
!
!		! User-definable events
!
!	OF 3FFH;  RETURN 'DoResize'
!	OF 400H;  RETURN 'User'
!	END
!	RETURN '???'
!==============================================================================
!-----------------------------------------------------------------------
! NOTES:
! Construct procedure executes automatically at the beginning of each procedure
! Destruct procedure executes automatically at the end of each procedure
! Construct/Destruct Procedures are implicit under the hood but don't have to be declared in the class as such if there is no need.
! It's ok to have them there for good measure, although some programmers only include them as needed.
! Normally some prefer Init() and Kill(),  but Destruct() can be handy to DISPOSE of stuff (to avoid mem leak)
!-----------------------------------------------------------------------
!EndRegion UltimateDebug



!!!!!!!!!!!!!



!Region UltimateDebugTraceSQL
!==============================================================================
!==============================================================================
!==============================================================================
UltimateDebugTraceSQL.Init              PROCEDURE(File aFile)
Retval    BYTE
  CODE
  SELF.UD &= NEW UltimateDebug
  SELF.UD.DebugPrefix = '@'
  SELF.MyFile &= aFile
  SELF.MyFileName = NAME(SELF.MyFile)
  SQLCALLBACK(SELF.MyFile, SELF.SQLCallBackInterface)
  RETURN
!==============================================================================
UltimateDebugTraceSQL.Kill              PROCEDURE
RetVal    BYTE
  CODE
  SQLCALLBACK(SELF.MyFile, SELF.SQLCallBackInterface, TRUE)
  RETURN
!==============================================================================
UltimateDebugTraceSQL.SQLCallBackInterface.ExecutingCode PROCEDURE(CONST *CSTRING inStr, *BYTE Err, *CSTRING FileErrCode, *CSTRING FileErrMsg)!, STRING
  CODE
  RETURN SELF.ExecutingCode(inStr, Err, FileErrCode,  FileErrMsg)!, STRING
!==============================================================================
UltimateDebugTraceSQL.ExecutingCode     PROCEDURE(CONST *CSTRING inStr, *BYTE Err, *CSTRING FileErrCode, *CSTRING FileErrMsg)!,STRING,VIRTUAL
  CODE
!!     Self.errcode = Errorcode()
!!     Self.errmsg  = choose(errorcode() = 90,FileError(),Error())
!!     Self.GetLastAction(opCode)
!!     Self.Opcode = opCode
  SELF.UD.Message('CALLBACKSQL(' & Err & '): ' & inStr)
  IF (Err) THEN
    SELF.UD.Message('ERROR(' & FileErrCode & '): ' & FileErrMsg & '')
  END
  RETURN(inStr)
!==============================================================================
!EndRegion UltimateDebugTraceSQL


!Region UltimateDebugTraceFile
!==============================================================================
!==============================================================================
!==============================================================================
UltimateDebugTraceFile.Init                                   PROCEDURE(FILE aFile)
!==============================================================================
  CODE
  SELF.UD &= NEW UltimateDebug
  !SELF.UD.DebugPrefix = '@'
  self.myfile &= afile
  self.myfilename = NAME(SELF.MyFile)

  SELF.UD.LOW_RYB('UltimateDebugTraceFile.Init(' & self.myfilename & ')')

  CALLBACK(self.myfile, Self.FileCallBackInterface)
  ! RA.2014.11.07 - This call is returning an error (30-Entry Not Found) when function is done.
  ! So the callback is never activated and no driver trace entries ever show up.
  ! At this point a new set of eyes needs to look at this and it's cause.
  RETURN
!==============================================================================
UltimateDebugTraceFile.Kill                                   PROCEDURE
!==============================================================================
  CODE
  SELF.UD.LOW_RYB('UltimateDebugTraceFile.Kill()')

  CALLBACK(self.myfile, Self.FileCallBackInterface, TRUE)
  DISPOSE(SELF.UD)
  RETURN
!==============================================================================
UltimateDebugTraceFile.FileCallBackInterface.FunctionCalled   PROCEDURE(SIGNED opCode, *Params Parameters, *CSTRING ErrCode, *CSTRING errmsg)
!==============================================================================
  CODE
  !SELF.UD.LOW_RYB('UltimateDebugTraceFile.FileCallBackInterface.FunctionCalled(' & opCode & ')')

  STOP('000: UltimateDebugTraceFile.FileCallBackInterface.FunctionCalled<13,10>' & |
       'opCode=' & opCode & '<13,10>ErrCode="' & errcode & '"<13,10>' & |
       'ErrMsg="' & errmsg & '"' |
      )

!  SELF.Direction = 'BEFORE:'                                      ! RA.2014.08.01 - Save direction
!  Self.Opcode = opCode
!  Self.GetLastAction(opCode)
!  SELF.UD.Debug('FUNCTION-CALLED: ' & CLIP(SELF.MyFileName) & ': ' & CLIP(SELF.Direction) & CLIP(SELF.FileAction) & |
!                '[' & SELF.OpCode & '] - ' & CLIP(SELF.ErrCode) & ' - ' & CLIP(SELF.ErrMsg) & ' (' & ERRORCODE() & '-' & ERROR() & ')')

  RETURN TRUE
!==============================================================================
UltimateDebugTraceFile.FileCallBackInterface.FunctionDone     PROCEDURE(SIGNED opCode, *Params Parameters, *CSTRING errcode, *CSTRING errmsg)
!==============================================================================
  CODE
  !SELF.UD.LOW_RYB('UltimateDebugTraceFile.FileCallBackInterface.FunctionDone(' & opCode & ')')

  STOP('001: UltimateDebugTraceFile.FileCallBackInterface.FunctionDone<13,10>' & |
       'opCode=' & opCode & '<13,10>ErrCode="' & errcode & '"<13,10>' & |
       'ErrMsg="' & errmsg & '"' |
      )

!  SELF.Direction = 'AFTER:'                                       ! RA.2014.08.01 - Save direction
!  Self.Opcode = opCode
!  Self.GetLastAction(opCode)
!  SELF.UD.Debug('FUNCTION-DONE: ' & CLIP(SELF.MyFileName) & ': ' & CLIP(SELF.Direction) & CLIP(SELF.FileAction) & |
!                '[' & SELF.OpCode & '] - ' & CLIP(SELF.ErrCode) & ' - ' & CLIP(SELF.ErrMsg) & ' (' & ERRORCODE() & '-' & ERROR() & ')')

  RETURN TRUE
!==============================================================================
! RA.2014.08.01 - Added the SELF.FileAction's literals that were not there (only the ADD existed) .
!                 Do not know what the SELF.Actionlevel means and what to set it to so I left that alone.
!                 Maybe Mike Hanson can explain what that is used for and the reason it's needed.
UltimateDebugTraceFile.GetLastAction                          PROCEDURE(SIGNED opCode)
!==============================================================================
  CODE

  CASE opCode
  OF DriverOp:Add                       ; SELF.FileAction = 'ADD'                       ; SELF.ActionLevel = 3
  OF DriverOp:AddLen                    ; SELF.FileAction = 'ADDLEN'
  OF DriverOp:Append                    ; SELF.FileAction = 'APPEND'
  OF DriverOp:AppendLen                 ; SELF.FileAction = 'APPENDLEN'
  OF DriverOp:BOF                       ; SELF.FileAction = 'BOF'
  OF DriverOp:BUILDFile                 ; SELF.FileAction = 'BUILDFILE'
  OF DriverOp:BUILDdyn                  ; SELF.FileAction = 'BUILDDYN'
  OF DriverOp:BUILDdynfilter            ; SELF.FileAction = 'BUILDDYNFILTER'
  OF DriverOp:BUILDevent                ; SELF.FileAction = 'BUILDEVENT'
  OF DriverOp:BUILDkey                  ; SELF.FileAction = 'BUILDKEY'
  OF DriverOp:BUFFER                    ; SELF.FileAction = 'BUFFER'
  OF DriverOp:BYTES                     ; SELF.FileAction = 'BYTES'
  OF DriverOp:BLOBSIZE                  ; SELF.FileAction = 'BLOBSIZE'
  OF DriverOp:CALLBACK                  ; SELF.FileAction = 'CALLBACK'
  OF DriverOp:CLEARfile                 ; SELF.FileAction = 'CLEARFILE'
  OF DriverOp:CLOSE                     ; SELF.FileAction = 'CLOSE'
  OF DriverOp:COMMIT                    ; SELF.FileAction = 'COMMIT'
  OF DriverOp:COPY                      ; SELF.FileAction = 'COPY'
  OF DriverOp:CREATE                    ; SELF.FileAction = 'CREATE'
  OF DriverOp:Delete                    ; SELF.FileAction = 'DELETE'
  OF DriverOp:DESTROY                   ; SELF.FileAction = 'DESTROY'
  OF DriverOp:DOblobproperty            ; SELF.FileAction = 'DOBLOBPROPERTY'
  OF DriverOp:DOkeyproperty             ; SELF.FileAction = 'DOKEYPROPERTY'
  OF DriverOp:DOproperty                ; SELF.FileAction = 'DOPROPERTY'
  OF DriverOp:DUPLICATE                 ; SELF.FileAction = 'DUPLICATE'
  OF DriverOp:DUPLICATEkey              ; SELF.FileAction = 'DUPLICATEKEY'
  OF DriverOp:EMPTY                     ; SELF.FileAction = 'EMPTY'
  OF DriverOp:ENDTRAN                   ; SELF.FileAction = 'ENDTRAN'
  OF DriverOp:EOF                       ; SELF.FileAction = 'EOF'
  OF DriverOp:FIXFORMAT                 ; SELF.FileAction = 'FIXFORMAT'
  OF DriverOp:FLUSH                     ; SELF.FileAction = 'FLUSH'
  OF DriverOp:FREESTATE                 ; SELF.FileAction = 'FREESTATE'
  OF DriverOp:GETBLOBDATA               ; SELF.FileAction = 'GETBLOBDATA'
  OF DriverOp:GETBLOBPROPERTY           ; SELF.FileAction = 'GETBLOBPROPERTY'
  OF DriverOp:GetFileKey                ; SELF.FileAction = 'GETFILEKEY'
  OF DriverOp:GetFilePtr                ; SELF.FileAction = 'GETFILEPTR'
  OF DriverOp:GetFilePtrLen             ; SELF.FileAction = 'GETFILEPTRLEN'
  OF DriverOp:GetKeyProperty            ; SELF.FileAction = 'GETKEYPROPERTY'
  OF DriverOp:GetKeyPtr                 ; SELF.FileAction = 'GETKEYPTR'
  OF DriverOp:GetNULLS                  ; SELF.FileAction = 'GETNULLS'
  OF DriverOp:GetProperty               ; SELF.FileAction = 'GETPROPERTY'
  OF DriverOp:GetState                  ; SELF.FileAction = 'GETSTATE'
  OF DriverOp:HOLD                      ; SELF.FileAction = 'HOLD'
  OF DriverOp:LOCK                      ; SELF.FileAction = 'LOCK'
  OF DriverOp:LOGOUT                    ; SELF.FileAction = 'LOGOUT'
  OF DriverOp:NAME                      ; SELF.FileAction = 'NAME'
  OF DriverOp:NEXT                      ; SELF.FileAction = 'NEXT'
  OF DriverOp:NULL                      ; SELF.FileAction = 'NULL'
  OF DriverOp:OPEN                      ; SELF.FileAction = 'OPEN'
  OF DriverOp:PACK                      ; SELF.FileAction = 'PACK'
  OF DriverOp:POINTERfile               ; SELF.FileAction = 'POINTERFILE'
  OF DriverOp:POINTERkey                ; SELF.FileAction = 'POINTERKEY'
  OF DriverOp:POSITIONfile              ; SELF.FileAction = 'POSITIONfile'
  OF DriverOp:POSITIONKEY               ; SELF.FileAction = 'POSITIONKEY'
  OF DriverOp:PREVIOUS                  ; SELF.FileAction = 'PREVIOUS'
  OF DriverOp:Put                       ; SELF.FileAction = 'PUT'
  OF DriverOp:PutBLOBData               ; SELF.FileAction = 'PUTBLOBDATA'
  OF DriverOp:PutFilePtr                ; SELF.FileAction = 'PUTFILEPTR'
  OF DriverOp:PutFilePtrLen             ; SELF.FileAction = 'PUTFILEPTRLEN'
  OF DriverOp:PutBlobData               ; SELF.FileAction = 'PUTBLOBDATA'
  OF DriverOp:RECORDSfile               ; SELF.FileAction = 'RECORDSFILE'
  OF DriverOp:RECORDSkey                ; SELF.FileAction = 'RECORDSKEY'
  OF DriverOp:RELEASE                   ; SELF.FileAction = 'RELEASE'
  OF DriverOp:REMOVE                    ; SELF.FileAction = 'REMOVE'
  OF DriverOp:RENAME                    ; SELF.FileAction = 'RENAME'
  OF DriverOp:RegetFile                 ; SELF.FileAction = 'REGETFILE'
  OF DriverOp:RegetKey                  ; SELF.FileAction = 'REGETKEY'
  OF DriverOp:RESETFile                 ; SELF.FileAction = 'RESETFILE'
  OF DriverOp:RESETKey                  ; SELF.FileAction = 'RESETKEY'
  OF DriverOp:RESETViewFile             ; SELF.FileAction = 'RESETVIEWFILE'
? OF DriverOp:RestoreState              ; SELF.FileAction = 'RESTORESTATE'
  OF DriverOp:ROLLBACK                  ; SELF.FileAction = 'ROLLBACK'
  OF DriverOP:SEND                      ; SELF.FileAction = 'SEND'
  OF DriverOP:SetBlobProperty           ; SELF.FileAction = 'SETBLOBPROPERTY'
  OF DriverOP:Setfile                   ; SELF.FileAction = 'SETFILE'
  OF DriverOP:Setfilekey                ; SELF.FileAction = 'SETFILEKEY'
  OF DriverOP:Setfileptr                ; SELF.FileAction = 'SETFILEPTR'
  OF DriverOP:SetKey                    ; SELF.FileAction = 'SETKEY'
  OF DriverOP:SetKeyKey                 ; SELF.FileAction = 'SETKEYKEY'
  OF DriverOP:SetKeyKeyPtr              ; SELF.FileAction = 'SETKEYKEYPTR'
  OF DriverOP:SetKeyProperty            ; SELF.FileAction = 'SETKEYPROPERTY'
  OF DriverOP:SetKeyPtr                 ; SELF.FileAction = 'SETKEYPTR'
  OF DriverOP:SetNull                   ; SELF.FileAction = 'SETNULL'
  OF DriverOP:SetNullS                  ; SELF.FileAction = 'SETNULLS'
  OF DriverOP:SetNonNull                ; SELF.FileAction = 'SETNONNULL'
  OF DriverOP:SetProperty               ; SELF.FileAction = 'SETPROPERTY'
  OF DriverOP:SetViewFields             ; SELF.FileAction = 'SETVIEWFIELDS'
  OF DriverOP:SHARE                     ; SELF.FileAction = 'SHARE'
  OF DriverOP:SKIP                      ; SELF.FileAction = 'SKIP'
  OF DriverOP:STARTTRAN                 ; SELF.FileAction = 'STARTTRAN'
  OF DriverOP:STREAM                    ; SELF.FileAction = 'STREAM'
  OF DriverOP:UNLOCK                    ; SELF.FileAction = 'UNLOCK'
  OF DriverOP:UNFIXFORMAT               ; SELF.FileAction = 'UNFIXFORMAT'
  OF DriverOP:VIEWSTART                 ; SELF.FileAction = 'VIEWSTART'
  OF DriverOP:VIEWSTOP                  ; SELF.FileAction = 'VIEWSTOP'
  OF DriverOP:WATCH                     ; SELF.FileAction = 'WATCH'
  ELSE                                  ; SELF.FileAction = '*BAD DRIVER OP*'
  END
  !SELF.UD.LOW_RYB('UltimateDebugTraceFile.GetLastAction(' & opCode & ' = ' & SELF.FileAction & ')')
  RETURN
!==============================================================================
! RA.2014.08.01 - Reworked with the new fields and avoid duplication of the message.
! RA.2014.08.05 - Parameters are passed but nothing is done with them.
UltimateDebugTraceFile.DriverMessage                          PROCEDURE(*Params Parameters)
!==============================================================================
  CODE
  SELF.UD.Debug('' & CLIP(SELF.MyFileName) & ': ' & CLIP(SELF.Direction) & CLIP(SELF.FileAction) & ' [' & SELF.OpCode & ']' & |
                ' - ' & CLIP(SELF.ErrCode) & ' - ' & CLIP(SELF.ErrMsg) & ' (' & ERRORCODE() & '-' & ERROR() & ')')
  RETURN
!==============================================================================
!EndRegion UltimateDebugTraceFile


!Region UltimateDebugTiming
!==============================================================================
StarDateClass.SetSimulatedTime     PROCEDURE(LONG TodayValue,LONG ClockValue)
  CODE
  SELF.SimulatedToday = TodayValue
  SELF.SimulatedClock = ClockValue

!==============================================================================
StarDateClass.GetClock             PROCEDURE!,LONG
  CODE
  RETURN CHOOSE(SELF.SimulatedClock=0, CLOCK(), SELF.SimulatedClock)

!==============================================================================
StarDateClass.GetToday             PROCEDURE!,LONG
  CODE
  RETURN CHOOSE(SELF.SimulatedToday=0, TODAY(), SELF.SimulatedToday)

!==============================================================================
!!! <summary>
!!! Return the Date+Time parameters as a "stardate".
!!! </summary>
StarDateClass.CalcStardate         PROCEDURE(LONG D,LONG T)!,REAL
  CODE
  RETURN D + (T - TIME:Midnight) / TIME:Day

!==============================================================================
!!! <summary>
!!! Return the difference in stardate values between the stardate parameter and the current Date+Time.
!!! </summary>
StarDateClass.CalcStardateDelta    PROCEDURE(REAL STAR1)!,REAL                         ! RA.2015.01.06 - Startdate difference from now
vDate1                          LONG,AUTO
vTime1                          LONG,AUTO
  CODE
  SELF.SplitStardate(STAR1,vDate1,vTime1)
  RETURN SELF.CalcStardateDelta(vDate1,vTime1)

!==============================================================================
!!! <summary>
!!! Return the difference in stardate values between the Date+Time parameters and the current Date+Time.
!!! </summary>
StarDateClass.CalcStardateDelta    PROCEDURE(LONG EarlierD,LONG EarlierT)!,REAL
  CODE
  RETURN SELF.CalcStardateDelta(EarlierD, EarlierT, SELF.GetToday(), SELF.GetClock())

!==============================================================================
!!! <summary>
!!! Return the difference in stardate values between the Date+Time parameter pairs.
!!! The return is the number of days (on the date side)
!!! </summary>
StarDateClass.CalcStardateDelta    PROCEDURE(LONG D1,LONG T1,LONG D2,LONG T2)!,REAL
StarDate1                       REAL,AUTO
StarDate2                       REAL,AUTO
  CODE
  StarDate1 = SELF.CalcStardate(D1, T1)
  StarDate2 = SELF.CalcStardate(D2, T2)
  RETURN StarDate2 - StarDate1

!==============================================================================
!!! <summary>
!!! Return the current Date+Time as a "stardate".
!!! </summary>
StarDateClass.GetStardate          PROCEDURE!,REAL
  CODE
  RETURN SELF.CalcStardate(SELF.GetToday(), SELF.GetClock())

!==============================================================================
!!! <summary>
!!! Split "stardate" into Date+Time
!!! </summary>
StarDateClass.SplitStardate        PROCEDURE(REAL StarDate_IN,*? D_OUT,*? T_OUT)
  CODE
  D_OUT = INT(StarDate_IN)
  T_OUT = (StarDate_IN - D_OUT) * TIME:Day + 1

!==============================================================================
! RA.2015.01.03 - Add stardate together and return a startdate
!!! <summary>
!!! Add stardate together and return a startdate
!!! </summary>
StarDateClass.AddDaysTime          PROCEDURE(REAL STAR1,REAL STAR2)!,REAL
vToday1                         LONG,AUTO
vClock1                         LONG,AUTO
vToday2                         LONG,AUTO
vClock2                         LONG,AUTO
  CODE
  SELF.SplitStardate(STAR1,vToday1,vClock1)
  SELF.SplitStardate(STAR2,vToday2,vClock2)
  RETURN SELF.AddDaysTime(vToday1,vClock1,vToday2,vClock2)

!==============================================================================
! RA.2015.01.03 - Add days+time together and return a startdate
!!! <summary>
!!! Add days+time together and return a startdate
!!! </summary>
StarDateClass.AddDaysTime         PROCEDURE(LONG D1,LONG T1,LONG D2,LONG T2)!,REAL
vToday3                         LONG,AUTO
vClock3                         LONG,AUTO
  CODE
  vToday3    = D2 + D1
  vClock3    = T2 + T1
  LOOP WHILE(vClock3 >= TIME:Day)
    vToday3 += 1
    vClock3 -= TIME:Day
  END
  RETURN SELF.CalcStardate(vToday3,vClock3)

!==============================================================================
! RA.2015.01.03 - StarDate days:hours:minutes:seconds output format
!!! <summary>
!!! Format stardate into ddd:hh:mm:ss
!!! </summary>
StarDateClass.FormatOneDayTime    PROCEDURE(REAL STAR1)!,STRING
vToday1                         LONG,AUTO
vClock1                         LONG,AUTO
  CODE
  SELF.SplitStardate(STAR1,vToday1,vClock1)
  RETURN SELF.FormatOneDayTime(vToday1,vClock1)

!==============================================================================
! RA.2015.01.02 - StarDate days:hours:minutes:seconds output format
!!! <summary>
!!! Format date+time into ddd:hh:mm:ss
!!! </summary>
StarDateClass.FormatOneDayTime    PROCEDURE(LONG D1,LONG T1)!,STRING
  CODE
  RETURN FORMAT(D1, @N03) & ':' & FORMAT(T1, @T04)

!==============================================================================
! RA.2015.01.03 - StarDate days:hours:minutes:seconds output format
!!! <summary>
!!! Format stardate into ddd:hh:mm:ss
!!! </summary>
StarDateClass.FormatDaysTime       PROCEDURE(REAL STAR1,REAL STAR2)!,STRING
vToday1                         LONG,AUTO
vClock1                         LONG,AUTO
vToday2                         LONG,AUTO
vClock2                         LONG,AUTO
  CODE
  SELF.SplitStardate(STAR1,vToday1,vClock1)
  SELF.SplitStardate(STAR2,vToday2,vClock2)
  RETURN SELF.FormatDaysTime(vToday1,vClock1,vToday2,vClock2)

!==============================================================================
! RA.2015.01.02 - StarDate days:hours:minutes:seconds output format
!!! <summary>
!!! Format date+time into ddd:hh:mm:ss
!!! </summary>
StarDateClass.FormatDaysTime       PROCEDURE(LONG D1,LONG T1,LONG D2,LONG T2)!,STRING
vReal3        REAL,AUTO
vToday3                         LONG,AUTO
vClock3                         LONG,AUTO
  CODE
  vReal3   = SELF.CalcStardateDelta(D1,T1,D2,T2)
  SELF.SplitStardate(vReal3,vToday3,vClock3)
  vClock3 += 1
  RETURN FORMAT(vToday3, @N03) & ':' & FORMAT(vClock3, @T04)

!==============================================================================


!==============================================================================
TimingClass.CONSTRUCT             PROCEDURE()
  CODE
  SELF.UD          &= NEW UltimateDebug
  SELF.oStarDate   &= NEW StarDateClass
  SELF.oLogFile    &= NEW ctAsciiLogger
  SELF.TimingQ     &= NEW TimingQueue
  !SELF.UD.Debug('TimingClass.CONSTRUCT')
  RETURN

!==============================================================================
! RA.2015.01.18 - Making SURE that the DISPOSEs are working correctly.
TimingClass.DESTRUCT              PROCEDURE()
  CODE
  !SELF.UD.Debug('TimingClass.DESTRUCT')
  !SELF.UD.Debug('TimingClass.DESTRUCT.DISPOSE(SELF.TimingQ)')
  !IF NOT    SELF.TimingQ &= NULL
    FREE   (SELF.TimingQ)
    DISPOSE(SELF.TimingQ)
  !END
  !SELF.UD.Debug('TimingClass.DESTRUCT.DISPOSE(SELF.oLogFile)')
  !IF NOT    SELF.oLogFile &= NULL
    DISPOSE(SELF.oLogFile)
  !END
  !SELF.UD.Debug('TimingClass.DESTRUCT.DISPOSE(SELF.oStarDate)')
  !IF NOT    SELF.oStarDate &= NULL
    DISPOSE(SELF.oStarDate)
  !END
  !SELF.UD.Debug('TimingClass.DESTRUCT.DISPOSE(SELF.UD)')
  !IF NOT    SELF.UD &= NULL
    DISPOSE(SELF.UD)
  !END
  RETURN

!==============================================================================
TimingClass.Init                  PROCEDURE(STRING pReportName)
  CODE
  SELF.ReportName                 = pReportName
  RETURN

!==============================================================================
TimingClass.Kill                  PROCEDURE()
  CODE
  SELF.Done(SELF.ReportName)
  RETURN

!==============================================================================
TimingClass.Description           PROCEDURE()!,STRING,DERIVED
  CODE
  RETURN 'Procedure Timing Class'

!==============================================================================
TimingClass.Find                  PROCEDURE(STRING pAppProcName, REAL pStarDate)
  CODE
  !SELF.UD.Debug('--> Find(' & pAppProcName & ',' & pStarDate & ')')
  IF (SELF._Find(pAppProcName)   = TRUE) THEN
    IF (SELF.TimingQ.ExecuteCount < TIMING:COUNT:MAXIMUM) THEN
      SELF.TimingQ.ExecuteCount += 1                                        ! Times this procedure was executed (MAXIMUM is 4,294,967,295)
    END
    SELF.TimingQ.ExecuteTime     = SELF.oStarDate.AddDaysTime(SELF.TimingQ.ExecuteTime, pStarDate)
    SELF.PutRow()
    !SELF.UD.Debug('ADD Item=' & CLIP(pAppProcName) & ' Time=' & SELF.oStarDate.FormatOneDayTime(pStarDate))
    !SELF.UD.Debug('TOTAL=' & CLIP(pAppProcName) & ' Time=' & SELF.oStarDate.FormatOneDayTime(SELF.TimingQ.ExecuteTime))
  ELSE
    CLEAR(SELF.TimingQ)
    SELF.TimingQ.AverageTime     = 0.0                                      ! StarDate [days:hours:minutes:secods]
    SELF.TimingQ.AppProcName     = pAppProcName                             ! Application-Procedure Name
    SELF.TimingQ.ExecuteCount    = 1                                        ! Times this procedure was executed (MAXIMUM is 4,294,967,295)
    SELF.TimingQ.ExecuteTime     = pStarDate                                ! StarDate [days:hours:minutes:secods]
    SELF.AddRow()
    !SELF.UD.Debug('NEW Item=' & CLIP(pAppProcName) & ' Time=' & SELF.oStarDate.FormatOneDayTime(pStarDate))
  END
  RETURN

!==============================================================================
TimingClass._Find                 PROCEDURE(STRING pAppProcName)!,BOOL
Index                             LONG(0)
Maximum                           LONG(0)
Found                             BOOL(FALSE)
  CODE
  Found        = FALSE
  Maximum      = SELF.Count()
  !SELF.UD.Debug('Looking for=' & CLIP(pAppProcName) & ', Maximum=' & Maximum)
  IF (Maximum > 0) THEN
    LOOP Index = 1 TO Maximum
      SELF.GetRow(Index)
      !SELF.UD.Debug('Index=' & Index & ', Name=' & SELF.TimingQ.AppProcName)
      IF (SELF.TimingQ.AppProcName = pAppProcName) THEN
        Found  = TRUE
        BREAK
      END
    END
  END
  !SELF.UD.Debug('Found=' & Found)
  RETURN Found

!==============================================================================
TimingClass.Done                  PROCEDURE(STRING pLogFileName)
Index                             LONG,AUTO
Maximum                           LONG,AUTO
TotalTime                         REAL,AUTO
LogLine                           STRING(4096),AUTO                       !HACK: arbitrary limit of LogFile
FileName                          STRING(255),AUTO
 CODE
  ! Calculate average time and Total Time
  Maximum                         = SELF.Count()
  TotalTime                       = 0.0
  LOOP Index = 1 TO Maximum
    SELF.GetRow(Index)
    IF (SELF.TimingQ.ExecuteCount < TIMING:COUNT:MAXIMUM) THEN
      SELF.TimingQ.AverageTime    = SELF.TimingQ.ExecuteTime / SELF.TimingQ.ExecuteCount
    ELSE
      SELF.TimingQ.AverageTime    = 0.0
    END
    TotalTime                    += SELF.TimingQ.ExecuteTime
    SELF.PutRow
  END

  CLEAR(SELF.TimingQ)
  SELF.TimingQ.AverageTime     = 0.0                                      ! StarDate [days:hours:minutes:secods]
  SELF.TimingQ.AppProcName     = 'TOTAL'                                  ! Application-Procedure Name
  SELF.TimingQ.ExecuteCount    = 0                                        ! Times this procedure was executed (MAXIMUM is 4,294,967,295)
  SELF.TimingQ.ExecuteTime     = TotalTime                                ! StarDate [days:hours:minutes:secods]
  SELF.AddRow()

  SORT(SELF.TimingQ, -SELF.TimingQ.AverageTime, -SELF.TimingQ.ExecuteCount)

  !SELF.UD.DebugQueue(SELF.TimingQ,'Show timing queue')

  ! RA.2015.01.14 - Create log file output
  FileName                     = CLIP(pLogFileName) & '_' & FORMAT(TODAY(),@D010-) & '_' & FORMAT(CLOCK(),@T04-) & '.CSV'
  SELF.oLogFile.Start(FileName)
  SELF.oLogFile.ClearLog()

  SELF.oLogFile.Add('"Average Time","Application-Procedure","Execution Count","Execution Time"')

  Maximum                         = SELF.Count()
  LOOP Index = 1 TO Maximum
    SELF.GetRow(Index)
    !SELF.UD.Debug('Index=' & FORMAT(Index, @N03) & ', Name=' & CLIP(SELF.TimingQ.AppProcName) & '')

    LogLine                       = ''
    IF (SELF.TimingQ.AverageTime    <> 0.0) THEN
      LogLine                     = CLIP(LogLine) & '"' & SELF.oStarDate.FormatOneDayTime(SELF.TimingQ.AverageTime) & '",'
    ELSE
      LogLine                     = CLIP(LogLine) & '"",'
    END
    LogLine                       = CLIP(LogLine) & '"' & CLIP(SELF.TimingQ.AppProcName) & '",'
    IF (SELF.TimingQ.ExecuteCount <> 0) THEN
      LogLine                     = CLIP(LogLine) & '"' & SELF.TimingQ.ExecuteCount & '",'
    ELSE
      LogLine                     = CLIP(LogLine) & '"",'
    END
    LogLine                       = CLIP(LogLine) &'"' & SELF.oStarDate.FormatOneDayTime(SELF.TimingQ.ExecuteTime) & '"'

    !SELF.UD.Debug('LogLine=' & CLIP(LogLine) & '')
    SELF.oLogFile.Add(CLIP(LogLine))
  END

  SELF.oLogFile.Finish(FileName)
  RETURN

!==============================================================================
TimingClass.Count                 PROCEDURE()!,LONG    !Alias for .Records
   CODE
   RETURN SELF._Records()

!==============================================================================
TimingClass._Records              PROCEDURE()!,LONG
   CODE
   RETURN RECORDS(SELF.TimingQ)

!==============================================================================
TimingClass.GetRow                PROCEDURE(LONG xPointer)!,LONG,PROC
   CODE
   GET(SELF.TimingQ, xPointer)
   RETURN ErrorCode()

!==============================================================================
TimingClass.AddRow                PROCEDURE()!,LONG,PROC
   CODE
   ADD(SELF.TimingQ)
   RETURN ErrorCode()

!==============================================================================
TimingClass.PutRow                PROCEDURE()!,LONG,PROC
   CODE
   PUT(SELF.TimingQ)
   RETURN ErrorCode()

!==============================================================================
!EndRegion UltimateDebugTiming


!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!Region Local Procedures
!------------------------------------------------------------------------------
!EndRegion Local Procedures
!------------------------------------------------------------------------------
!ThreadDebugLocal                        CLASS(),TYPE,MODULE('UDRA_UltimateDebug.CLW'),LINK('UDRA_UltimateDebug.CLW')  !,_ABCLinkMode_),DLL(_ABCDllMode_)
!Construct                                   PROCEDURE()
!Destruct                                    PROCEDURE()
!                                        END
ThreadDebugLocal.Construct               PROCEDURE
  CODE
  IF (SELF.DebugMe)
    PARENT.Debug(':DEBUGME ThreadDebugLocal.Construct')
  END
  RETURN
!------------------------------------------------------------------------------
ThreadDebugLocal.Destruct                PROCEDURE
  CODE
  IF (SELF.DebugMe)
    PARENT.Debug(':DEBUGME ThreadDebugLocal.Destruct')
  END
  RETURN
!------------------------------------------------------------------------------

